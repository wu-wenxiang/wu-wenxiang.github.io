---
layout:         post
title:          用户态程序排错教程-IIS
category:       course
description:    本文介绍：IIS/ASP.NET中常见的几种需要用到用户态Debug技术的问题，并给出了相应的排查思路和具体的案例分析
---

## 简介

IIS/ASP.NET站点经常会遇到 **Crash**、**HTTP500** (Internal Error)、**High CPU**、**Hang** (Slow Response)、**High Connections**、**Memory Leak**等问题，这些问题单纯通过分析Log或者Trace很难定位，必须Debug。本文总结了一些关于这些问题的常规排查思路和具体的案例分析。

## 通用技巧

### IIS Log
- Flush IIS log: `netsh http flush logbuffer`
- Filter long time (>10s) requests：`type iis.log | findstr /R "[0-9][0-9][0-9][0-9][0-9]$"`
- Analyze IIS Log: requests / second

		logPath = "u_ex160202.log"
		import re
		from collections import Counter
		aList = [line.split()[1] for line in open(logPath) if re.search("^2\d{3}", line)]
		aCounter = Counter(aList)
		aFile = open("b.csv", "w")
		for k in sorted(aCounter): aFile.write("%s, %d\n" % (k, aCounter[k]))
		[aFile.write("%s, %d\n" % (k, aCounter[k])) for k in sorted(aCounter)]


### Dump IIS requests
- `!mex.aspxpagesext -n`
- `!psscor2.aspxpages`
- `!psscor4.aspxpages`

## Hang

### 常规思路
- 确定是不是IIS真的Hang了？
	- 通常这类问题报上来都是因为客户端访问站点发现延迟，我们要首先要确定IIS是否存在延迟响应的现象，很多时候Hang不是因为IIS延迟响应，而是客户端本身hang住了，或者网络重传。
	- 检查的方法是IIS Log的TimeTaken字段
- 如果IIS真的Hang了，就
	- 间隔10s左右收集3个Dump，手动收集不便就用DebugDiag自动收集
	- 分析Callstack + .NET Objects + Review Code

### 案例：

## HTTP500 or Other Firstchance Exception

### 常规思路
- 确定异常类型
	- 通常在Application Log或者EventLog（Application）中可以看到这些异常
- 收集FirstChance Dump
	- Prodump或者DebugDiag设置规则

### Case：180703419160611
- Symptom
	- SSO Site couldn't login sometimes
	- SSO Site will verify username/password by LDAP protocol
	- iisreset could workaround this issue
- Analysis
	- Application Log: LDAP verify failed due to **System.Runtime.InteropServices.COMException**
	- Collect Dump for this first chance exception

			0:165> kL20
			# Child-SP          RetAddr           Call Site
			00 00000000`27f2a448 000007fe`fd8610dc ntdll!ZwWaitForSingleObject+0xa
			01 00000000`27f2a450 000007fe`f71149cf KERNELBASE!WaitForSingleObjectEx+0x79
			02 00000000`27f2a4f0 000007fe`f7114987 clr!CLREventWaitHelper2+0x38
			......
			1b 00000000`27f2cc10 000007fe`f4e83a55 clr!IL_Throw+0xe3
			1c 00000000`27f2cdb0 000007fe`f4dea3ec System_DirectoryServices_ni!System.DirectoryServices.DirectoryEntry.Bind(Boolean)+0x99655
			1d 00000000`27f2ce60 000007fe`f4dea12a System_DirectoryServices_ni!System.DirectoryServices.DirectoryEntry.Bind()+0x2c
			1e 00000000`27f2cea0 000007fe`f4df500d System_DirectoryServices_ni!System.DirectoryServices.DirectoryEntry.get_AdsObject()+0x2a
			1f 00000000`27f2cee0 000007fe`f4df50ef System_DirectoryServices_ni!System.DirectoryServices.PropertyValueCollection.PopulateList()+0x1d
			
			DirectoryEntry Bind
			-------------------
			Path LDAP://xxxxx.cn/DC=xxxxx,DC=cn
			
			Last Exception:
			Address: 0x000000067f245040
			HResult: 0x800703fa     // Illegal operation attempted on a registry key that has been marked for deletion.
			Type: System.Runtime.InteropServices.COMException
			Message: 试图在标记为删除的注册表项上进行不合法的操作。
			
			Address          Completed Timeout Time (secs) ThreadId ReturnCode Verb Url
			00000000ff49d3e0        no     110           2      165        200 POST /LoginLight.aspx?challengeNumber=N3JwNDllYXdlb3NjYXNzaGNvamp3N213ZzZ3OThmZXVienNwOGhoeDJ6NmY2YmxmaHdwdmhyc3J5YmtmMHJpNnBmazNoaTU2MWx5cWhlbG9iaWQ1ZjlpdXRvcHVoNGFpdHAzYWU2cGllOHY2bHBybXlhN2drbjV4bmcwNHBnZGphaHhoNzBzeWVwMzlwMjd3bHdwamhndWQxdGs0YXZmZDJmeG40dnVrcmxrdGtpcmh6eHdxajFrZ3prN2g1MHg5cXZrdXhrcmV4bTdoa2R5MzZtZGwyM2MzZmV6Zmxpamt0eThoZXNpaHphZHdjOHNydzB2d3EzemZ0djF5MGxqMg%3d%3d&flag=3&systemCode=GRP030&RetutnUrl=http%3a%2f%2ferp.xxxxx.cn%2flogin%2fwdLogin.jsp%3flogintype%3d1
 
	- Procmon Log

			3:31:47.3882588 PM      w3wp.exe           11400    RegQueryKey    5180       HKCU\Software\Classes                 HIVE UNLOADED         Query: Name, Length: 384            0
			3:31:47.3942482 PM      w3wp.exe           11400    RegQueryKey    5180       HKCU\Software\Classes                 HIVE UNLOADED         Query: Name, Length: 384            0
			3:31:47.5632983 PM      w3wp.exe           11400    RegQueryKey    9740       HKCU\Software\Classes                 HIVE UNLOADED         Query: Name, Length: 384            0

	- Research
		- Similar to [MSDN Blog](https://blogs.msdn.microsoft.com/distributedservices/2009/11/06/a-com-application-may-stop-working-on-windows-server-2008-when-the-identity-user-logs-off/)
		- Check Promon & Netmon, LDAP requests didn't be sent to Domain Controller.
		- HIVE UNLOADED warning could be found.
		- Account about w3wp: XXXXX\ssoadmin, from Procmon Log, ssoadmin is a domain account, since XXXX is domain name (we can find domain name & machine name in dump)
		- Call with customer, he confirm ssoadmin is domain account & he logon/logoff before this issue happened.

	- Solution
		- Do not log on to the server for interactive sessions by using a service account.
		- Disable the related Windows User Profile Service feature. To do this, follow these steps: 
			- Open the Group Policy editor (Gpedit.msc) on the affected server.
			- Open the UserProfiles folder in the following path: `Computer Configuration > Administrative Templates > System > UserProfiles`
			- Locate the Do not forcefully unload the user registry at user logoff setting.
			- Change the setting to Enabled .

## Crash

### 案例：

## High CPU

### 常规思路
- 确定是不是W3WP进程造成了High CPU，是一个还是多个？
	- TaskManager
	- Performance Counter
	- Xperf
- 对造成High CPU的进程，间隔10秒收集3个Dump，手动收集不便也可以用DebugDiag或者Procdump自动收集
- 分析Dump，看CPU时间花在哪个线程上，线程当时在干嘛？

### 案例：359491212221411
- 问题现象：
	- w3wp进程CPU持续冲高，100%
	- 客户间隔22分钟收集了2个Dump
- 分析Dump
	- 首先看收集Dump时，CPU高不高？`!threadpool`命令：

			0:044> !threadpool
			CPU utilization: 100%
			Worker Thread: Total: 27 Running: 9 Idle: 18 MaxLimit: 400 MinLimit: 200
			Work Request in Queue: 0
			--------------------------------------
			Number of Timers: 2
			--------------------------------------
			Completion Port Thread:Total: 1 Free: 1 MaxFree: 8 CurrentLimit: 1 MaxLimit: 400 MinLimit: 200

		可以看到CPU用到了100%，两个Dump都是这样。

	- 然后看时间花在哪个线程（时间都去哪儿了）？

			# Dump1
			
			0:044> .time
			Debug session time: Mon Dec 22 17:37:25.000 2014 (UTC + 8:00)
			System Uptime: 0 days 5:29:36.639
			Process Uptime: 0 days 5:27:12.000
			  Kernel time: 0 days 0:14:54.000
			  User time: 0 days 2:27:38.000
			0:044> !runaway 3
			 User Mode Time
			  Thread       Time
			  23:fbc       0 days 0:20:22.314
			  25:248       0 days 0:04:52.283
			  29:b4c       0 days 0:04:39.101
			  30:12f8      0 days 0:04:32.486
			  35:47c       0 days 0:04:10.709
			  32:274       0 days 0:04:07.620
			  26:dc8       0 days 0:04:00.194
			  24:10cc      0 days 0:03:57.464
			  31:3d8       0 days 0:03:52.082
			  28:a90       0 days 0:03:50.382
			  45:11b0      0 days 0:03:17.637
			
			# Dump2
			
			0:043> .time
			Debug session time: Mon Dec 22 17:59:47.000 2014 (UTC + 8:00)
			System Uptime: 0 days 5:51:57.197
			Process Uptime: 0 days 5:49:34.000
			  Kernel time: 0 days 0:16:35.000
			  User time: 0 days 3:23:36.000
			0:043> !runaway 3
			 User Mode Time
			  Thread       Time
			  23:fbc       0 days 0:41:57.481
			  28:b4c       0 days 0:26:12.786
			  43:e80       0 days 0:08:27.268
			  24:248       0 days 0:05:03.749
			  29:12f8      0 days 0:04:43.953
			
			0:043> vertarget
			Windows 7 Version 7601 (Service Pack 1) MP (4 procs) Free x64
			......

		可以看到，间隔22分钟的两个Dump，23、28两个线程各自花了20分钟左右的UserMode CPU时间。这是一个4Core的机器，仅这两个线程，就占了约50%的CPU。

	- 然后看这两个线程在做什么事（没想到你是这种线程）？

			# Dump2
			
			0:023> kL
			 # Child-SP          RetAddr           Call Site
			00 00000000`0ff5c8a0 000007fe`f8185ec6 System_ni!System.Text.RegularExpressions.RegexInterpreter.Advance(Int32)+0x24
			01 00000000`0ff5c8d0 000007fe`f818515e System_ni!System.Text.RegularExpressions.RegexInterpreter.Go()+0x696
			02 00000000`0ff5c930 000007fe`f8189095 System_ni!System.Text.RegularExpressions.RegexRunner.Scan(System.Text.RegularExpressions.Regex, System.String, Int32, Int32, Int32, Int32, Boolean, System.TimeSpan)+0x1fe
			03 00000000`0ff5c9a0 000007fe`f8189270 System_ni!System.Text.RegularExpressions.Regex.Run(Boolean, Int32, System.String, Int32, Int32, Int32)+0x1a5
			04 00000000`0ff5ca60 000007fe`9c698a9b System_ni!System.Text.RegularExpressions.Regex.Match(System.String)+0x50
			05 00000000`0ff5cac0 000007fe`9c68494f XXXX!YYYY.parseMultiUserInforIds(ZZZ1)+0x1eb
			06 00000000`0ff5cc50 000007fe`9c682f10 XXXX!YYYY.ReadEmployeeRelationshipFromFile(ZZZ2)+0x150f
			07 00000000`0ff5d9c0 000007fe`9c7570df XXXX!YYYY.ImportEmployeeRelationship()+0x630
			08 00000000`0ff5dc90 000007fe`9b5455b2 DynamicClass.lambda_method(System.Runtime.CompilerServices.Closure, System.Web.Mvc.ControllerBase, System.Object[])+0x4f
			09 00000000`0ff5dcc0 000007fe`9b545687 System_Web_Mvc!System.Web.Mvc.ReflectedActionDescriptor.Execute(System.Web.Mvc.ControllerContext, System.Collections.Generic.IDictionary`2<System.String,System.Object>)+0xf2
			
			0:023> ~28s
			*** WARNING: Unable to verify checksum for mscorlib.ni.dll
			clr!JIT_GetSharedNonGCStaticBase__PatchTLSLabel+0x17:
			000007fe`fa224442 740c            je      clr!JIT_GetSharedNonGCStaticBase__PatchTLSLabel+0x25 (000007fe`fa224450) [br=0]
			0:028> kL10
			 # Child-SP          RetAddr           Call Site
			00 00000000`107bc4d8 000007fe`f902c159 clr!JIT_GetSharedNonGCStaticBase__PatchTLSLabel+0x17
			01 00000000`107bc4e0 000007fe`f8180740 mscorlib_ni!System.Globalization.CharUnicodeInfo.InternalGetCategoryValue(Int32, Int32)+0x19
			02 00000000`107bc520 000007fe`f8186752 System_ni!System.Text.RegularExpressions.RegexCharClass.CharInCategory(Char, System.String, Int32, Int32, Int32)+0x100
			03 00000000`107bc580 000007fe`f8186242 System_ni!System.Text.RegularExpressions.RegexCharClass.CharInClassRecursive(Char, System.String, Int32)+0x82
			04 00000000`107bc610 000007fe`f818515e System_ni!System.Text.RegularExpressions.RegexInterpreter.Go()+0xa12
			05 00000000`107bc670 000007fe`f8189095 System_ni!System.Text.RegularExpressions.RegexRunner.Scan(System.Text.RegularExpressions.Regex, System.String, Int32, Int32, Int32, Int32, Boolean, System.TimeSpan)+0x1fe
			06 00000000`107bc6e0 000007fe`f8189270 System_ni!System.Text.RegularExpressions.Regex.Run(Boolean, Int32, System.String, Int32, Int32, Int32)+0x1a5
			07 00000000`107bc7a0 000007fe`9c698a9b System_ni!System.Text.RegularExpressions.Regex.Match(System.String)+0x50
			08 00000000`107bc800 000007fe`9c68494f XXXX!YYYY.parseMultiUserInforIds(ZZZ1)+0x1eb
			09 00000000`107bc990 000007fe`9c682f10 XXXX!YYYY.ReadEmployeeRelationshipFromFile(ZZZ2)+0x150f
			0a 00000000`107bd700 000007fe`9c7570df XXXX!YYYY.ImportEmployeeRelationship()+0x630
			0b 00000000`107bd9d0 000007fe`9b5455b2 DynamicClass.lambda_method(System.Runtime.CompilerServices.Closure, System.Web.Mvc.ControllerBase, System.Object[])+0x4f
			0c 00000000`107bda00 000007fe`9b545687 System_Web_Mvc!System.Web.Mvc.ReflectedActionDescriptor.Execute(System.Web.Mvc.ControllerContext, System.Collections.Generic.IDictionary`2<System.String,System.Object>)+0xf2

		可看到他们都在做正则表达式处理，这个和字符串处理一样，最耗CPU了，但是耗成这样，需要继续看：
		
			0:028> !mex.grep 2[38] !mex.aspxpagesext -n
			00000002ffd16518        no     110        1561       28        200 POST /XXXX/ImportEmployeeRelationship
			000000040022fd48        no     110        2334       23        200 POST /XXXX/ImportEmployeeRelationship

		这两个线程都是直接负责处理HttpRequest的同步线程，是同一个请求：`POST /XXXX/ImportEmployeeRelationship`，都执行了很长的时间1561秒/2334秒，两者的callstack也是一样的，都涉及到了3个方法的调用：
		
		- parseMultiUserInforIds
		- ReadEmployeeRelationshipFromFile
		- ImportEmployeeRelationship

	- 接下来反编译代码，Review Code，发现ReadEmployeeRelationshipFromFile调用parse时，确实存在值得优化的多重循环。

			// YYYY
			private void ReadEmployeeRelationshipFromFile(ZZZ2)
			{
				// ......
				foreach (string[] current2 in list)
				{
				    // ......
				    for (int k = 0; k < simpleTables.Length; k++)
				    {
						// ......
						while (enumerator3.MoveNext())
						{
						    // ......
							int[] users = this.parseMultiUserInforIds(ZZZ1);
							// ......
						}	
						// ......
				    }
					// ......
				}
			}

	- 修改代码，解决。
	- 如果希望找到哪一种循环花了太多的时间，可以Dump循环变量，看各自执行了多少次。

### Case：430343418260611
- Symptom
	- IIS 7.5 site, w3wp process CPU high sometimes
	- Once this issue happened, CPU usage won't down, till AppPool recycle
- Analysis
	- Catch dumps when this issue happened
	- !runaway 3, diff dumps, find similar callstack

			# Child-SP          RetAddr           Call Site
			00 00000000`15fbaba0 000007fe`f6b86089 mscorlib_ni!System.Collections.Generic.Dictionary`2[[System.__Canon, mscorlib],[System.Char, mscorlib]].FindEntry(System.__Canon)+0xffffffff`fffca35c
			01 00000000`15fbac10 000007fe`994f3a5a mscorlib_ni!System.Collections.Generic.Dictionary`2[[System.__Canon, mscorlib],[System.Char, mscorlib]].ContainsKey(System.__Canon)+0xffffffff`ff4a6709
			02 00000000`15fbac40 000007fe`98c85971 XXXXX!YYYYY.Current_TransactionCompleted(System.Object, System.Transactions.TransactionEventArgs)+0x12a

			# Child-SP          RetAddr           Call Site
			00 00000000`1562de50 000007fe`994f34c4 mscorlib_ni!System.Collections.Generic.Dictionary`2[[System.__Canon, mscorlib],[System.Char, mscorlib]].Insert(System.__Canon, Char, Boolean)+0xffffffff`fffdd470
			01 00000000`1562dee0 000007fe`99a714b3 XXXXX!YYYYY.AttachTransactionEvent()+0x154

	- Reflect FindEntry() & Dump dictionary object by `!dso`, find `dict.entries[1].next == 1`, which could cause dead loop if `this.entries[i].hashCode != num` (We could confirm `this.entries[i].key === key`)

			// System.Collections.Generic.Dictionary<TKey, TValue>
			private int FindEntry(TKey key)
			{
			    if (key == null)
			    {
			        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);
			    }
			    if (this.buckets != null)
			    {
			        int num = this.comparer.GetHashCode(key) & 2147483647;
			        for (int i = this.buckets[num % this.buckets.Length]; i >= 0; i = this.entries[i].next)
			        {
			            if (this.entries[i].hashCode == num && this.comparer.Equals(this.entries[i].key, key))
			            {
			                return i;
			            }
			        }
			    }
			    return -1;
			}

	- Reflect Insert(), find there also a for-loop which similar to FindEntry()
	- From dump, we could know this dictionary is a static object, which shared access(read & write) in multiple threads. According to [MSDN](https://msdn.microsoft.com/en-us/library/xfhwa508(v=vs.110).aspx): **A Dictionary<TKey, TValue> can support multiple readers concurrently, as long as the collection is not modified. Even so, enumerating through a collection is intrinsically not a thread-safe procedure. In the rare case where an enumeration contends with write accesses, the collection must be locked during the entire enumeration. To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.**

- Conclusion
	- Dictionary not thread safe, so dictionary instance structure crashed when multiple threads access (write & read)
	- Damaged dict instance caused FindEntry() & Insert() go to dead loop
	- This issue could simply repro by write a demo, multiple threads insert a static dict.

- Solution
	- Add lock, or use ConcurrentDictionary or System.Collections.Immutable.ImmutableDictionary
	- Refer to [MSDN](https://msdn.microsoft.com/en-us/library/xfhwa508(v=vs.110).aspx)

## Memory Leak

### 案例：

## High Connection

### 案例：