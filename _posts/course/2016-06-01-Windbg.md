---
layout:         post
title:          用户态程序排错教程-Windbg
category:       course
description:    本文介绍：Windbg的基本功能，常用的插件和命令，以及Windbg在实际案例中的应用。
---

## QuickStart

### 简介

Windbg是Windows平台上的Debug Tool，Unix/Linux世界中功能类似的产品是GDB。WinDbg作为免费的Debugging Tools for Windows包的组成部分被发行（Windbg还有一个Internal Usage的版本，功能更为强大）。WinDbg是有GUI界面的，但它与命令行调试器前端如KD，CDB，NTSD共享了一个调试器后端。

Windbg的功能包括：

- Windbg分为开放版本和内部版本。
- 可用于调试用户态下的应用程序、以及核心态下的驱动程序和操作系统自身。
- 可用于在线的Live Debug或者离线Debug（Memory Dump / TTTracing）
- WinDbg能从服务器自动装载匹配的调试符号文件，如PDB文件。调试符号文件在源代码文件与二进制可执行程序之间创建对应关系。Microsoft的公开的（PDB文件也有Private版本，Private Symbol提供了更详细的信息）符号服务器提供了Windows 2000以后各版本操作系统及服务包的绝大部分符号。

### Install & Config

- Install
	- Public Download [Get Debugging Tools for Windows (WinDbg) (from the SDK)](https://go.microsoft.com/fwlink/p/?LinkId=536682)
	- [Internal Version](http://sharepoint/sites/debug/Tips/Windows%20Debugger.aspx)，或者这个链接：http://debug。别费力气了，非微软员工账号或者在外网都访问不了的。`\\dbg\privates\latest\`，可以直接到这里下载。
	- `dbg_x86.msi`和`dbg_amd64.msi`都装上，分别用于Debug 32bit和64bit进程。安装路径分别是：`C:\Debugger`和`C:\Debugger64`
	- 自动化Dump分析工具也推荐安装：
		- [Matlas](http://toolbox/MAtlas)，MS Internal Usage
		- [DebugDiag2.2](https://www.microsoft.com/en-us/download/details.aspx?id=49924), for Vista+
		- [DebugDiag1.2](https://www.microsoft.com/en-us/download/details.aspx?id=26798), for XP or 2003
- Config
	- Setup symbol path and extension path for WinDBG

		We will add the following environment variables to system to system variables, then you don't need to set them for each debugging session.
     
		![environmenVariable.png](http://7xudfs.com1.z0.glb.clouddn.com/c357331791434ffe98d84126ee441091-environmenVariable.png)
		
		这里设置了两个环境变量：`_NT_SYMBOL_PATH`和`_NT_DEBUGGER_EXTENSION_PATH`。其实`_NT_DEBUGGER_EXTENSION_PATH`不建议设置，因为extension 64bit/32bit不兼容的。推荐将64bit的extenstion直接添加到Windbg 64bit安装目录的winext目录中，将32bit的extenstion直接添加到Windbg 32bit安装目录的winext目录中.

	- Symbol Path
		- Internal的Symbol Path是：
				
				cache*c:\symbols;srv*http://symweb;SRV*\\gcrcssfs\Products\Symbols
				# 或者
				SRV*d:\SymCache*http://symweb;SRV*\\gcrcssfs\Products\Symbols
		- Public Symbol Server (Microsoft)：
			
				srv*c:\mss*http://msdl.microsoft.com/download/symbols
		- Public Symbol Server (Citrix)：	

				srv*c:\css*http://ctxsym.citrix.com/symbols
		- 动态配置Symbol的命令：
		
				.symfix c:\mss
				.sympath+ srv*c:\css*http://ctxsym.citrix.com/symbols

### Common Usage

- Attach Process
- Attach Process on launch
- Open Crash Dump & Analysis
- Open TTTracing & Analysis

### Windbg Reference

- [MSDN](https://msdn.microsoft.com/en-us/library/windows/hardware/ff551063(v=vs.85).aspx)
- [windbg.org](http://www.windbg.org/)
- [QuickStart](https://msdn.microsoft.com/en-us/library/windows/hardware/dn745911(v=vs.85).aspx)
- [windbg.info](http://www.windbg.info/)

## 基本命令

### Command Reference
- Windbg.ino: [Common Commands](http://www.windbg.info/doc/1-common-cmds.html), also you could download: [PDF](http://www.windbg.info/download/doc/pdf/WinDbg_cmds.pdf)
- 练习工具: [CrashMe](http://www.windbg.info/apps/46-crashme.html)

### Command Details

- `.time`：当前时间，系统和进程运行了多长时间
- `!dml_proc`：进程PID
- `!cl`：Command Line
- `lm`：列出所有dll，`lmvm clr`：查看clr dll的信息
- `vertarget`：看target系统信息，`version`：target和debugger两者的信息
- `~`：列出所有的线程（可以看系统线程号和进程内线程号对应关系）
- `~1s`：切换到1号线程（进程内Thread ID）
- `!userexts.dw -aefhvsprwoz [hwnd/pwnd]`: Displays information on windows in system

		struct HWND__ * hwnd = 0x00000000`0005008c
		!userexts.dw -v hwnd 0x00000000`0005008c 

- `dt`

		0:015> dt  000000c8`00fdc0e0 tagMSG
		  shdocvw!tagMSG
		     +0x000 hwnd             : 0x00880028`50010000 HWND__
		     +0x008 message          : 0x1e00d6
		     +0x010 wParam           : 0x00003043`394a4aee
		     +0x018 lParam           : 0n20480
		     +0x020 time             : 0x2f0e0000
		     +0x024 pt               : tagPOINT

- `dx`
		
		0:015> dx -r1 -n (*((user32!tagMSG *)0xc800fdc0e0))
		(*((user32!tagMSG *)0xc800fdc0e0)) : {msg=0x1e00d6 wp=0x3043394a4aee lp=0x5000} [Type: tagMSG]
	      [+0x000] hwnd             : 0x88002850010000 [Type: HWND__ *]
	      [+0x008] message          : 0x1e00d6 [Type: unsigned int]
	      [+0x010] wParam           : 0x3043394a4aee [Type: unsigned __int64]
	      [+0x018] lParam           : 20480 [Type: __int64]
	      [+0x020] time             : 0x2f0e0000 [Type: unsigned long]
	      [+0x024] pt               [Type: tagPOINT]


## 常用插件

### sos

### sosext

### psscor2/psscor4

### mex

### iisinfo

## 常用技巧

### Save Modules from Dump
- 保存单个DLL
	- 参考：[Commands to ListExtract dlls from Memory Dump using WinDbg](https://blogs.technet.microsoft.com/sateesh-arveti/2012/02/09/commands-to-listextract-dlls-from-memory-dump-using-windbg/)
	- `kML`看模块名称
	- `lmvm <模块名称>`，找到起始地址（比如：00040026）
	- `!SaveModule 00040026 c:\test.dll`
	- 用ILSpy反编译Managed DLL来Review Code
- 保存所有DLL
	- `!psscor4.sam d:\moduleFolder`
	- `!mex.writemodule -a -p d:\moduleFolder\`，目录 **d:\moduleFolder** 需要提前创建好。
	- Matlas
		
		![Matlas-SAM.png](http://7xudfs.com1.z0.glb.clouddn.com/ebae808f8441465a8cc2c68ae985ef60-Matlas-SAM.png)

### 加载Private Symbol
- 何时需要手动加载Private Symbol

	如果在分析Dump时，打印callstack出现如下现象，说明我们的Debugger没有找到这个Assembly对应的symbol文件（PDB文件），此时我们需要手动加载Private Symbol。

		0:001> kL
		 # ChildEBP RetAddr  
		00 0253f988 10001861 ws2_32!recvfrom+0xd1
		WARNING: Stack unwind information not available. Following frames may be wrong.
		01 0253ff88 771a3677 TrayDetour+0x1861
		02 0253ff94 77a59d72 kernel32!BaseThreadInitThunk+0xe
		03 0253ffd4 77a59d45 ntdll!__RtlUserThreadStart+0x70
		04 0253ffec 00000000 ntdll!_RtlUserThreadStart+0x1b

	上文中可以看到：**WARNING: Stack unwind information not available. Following frames may be wrong.**，同时随后的**TrayDetour+0x1861**，说明我们没有找到TrayDetour模块的pdb文件，需要手动加载

- 加载步骤
	- 将dll和pdb文件拷贝到一起
	- Windbg中输入`.sympath+"C:\local\private_symbols"`命令，添加symbol文件路径：`C:\local\private_symbols`
	
			0:015> .sympath+"C:\local\private_symbols"
			Symbol search path is: cache*c:\symbols;srv*http://symweb;C:\local\private_symbols
			Expanded Symbol search path is: cache*c:\symbols;srv*http://symweb;c:\local\private_symbols
			
			************* Symbol Path validation summary **************
			Response                         Time (ms)     Location
			Deferred                                       cache*c:\symbols
			Deferred                                       srv*http://xxxx
			OK                                             C:\local\private_symbols

	- Windbg中输入`.reload /f VPhone.dll`命令，加载symbol
	
			0:015> .reload /f VPhone.dll
			*** WARNING: Unable to verify checksum for VPhone.dll
			0:015> kL
			 # ChildEBP RetAddr  
			00 0841c5f0 76e56a44 ntdll!KiFastSystemCallRet
			.....
			0d 0841c89c 76e2f987 ntdll!ExecuteHandler+0x24
			0e 0841c928 76e57057 ntdll!RtlDispatchException+0x127
			0f 0841c928 591690f2 ntdll!KiUserExceptionDispatcher+0xf
			10 0841cd90 59166f98 VPhone!CBitmap::CreateCompatibleBitmap+0x12
			11 0841ce40 59557062 VPhone!CPhoneButton::DrawItem+0x168
			12 0841ce4c 5955042e VPhone!CStatic::OnChildNotify+0x1a
			......
	
	- 如果symbol文件和Assembly不匹配，会加载不成功

			0:001> .reload /f TrayDetour.dll
			*** WARNING: Unable to verify checksum for TrayDetour.dll
			*** ERROR: Symbol file could not be found.  Defaulted to export symbols for TrayDetour.dll - 
			
			************* Symbol Loading Error Summary **************
			Module name            Error
			TrayDetour             PDB not found : cache*c:\symbols
			                       The server has never indexed the given version of the given file : srv*http://xxxx
			                       The system cannot find the file specified : c:\local\private_symbols
			                       Signature does not match : c:\symbols\TrayDetour.pdb\DD923C1A69F24CB5BFBF5FCA83CF690F1\TrayDetour.pdb
			
			The following location did not respond and were excluded during symbol loading:
			srv*\\gcrcssfs\products\symbols
			
			You can troubleshoot most symbol related issues by turning on symbol loading diagnostics (!sym noisy) and repeating the command that caused symbols to be loaded.
			You should also verify that your symbol search path (.sympath) is correct.
	
		这里给出了加载pdb文件失败的原因：**Signature does not match**

	- 如何验证symbol文件和Assembly是否匹配
		- 可以用[Chkmatch](http://www.debuginfo.com/tools/chkmatch.html)工具
			- 命令：

					ChkMatch.exe -c C:\local\private_symbols\VPhone.dll C:\local\private_symbols\VPhone.pdb

			- 匹配的情况

					C:\Users\wenw\Downloads\chkmatch>ChkMatch.exe -c C:\local\private_symbols\VPhone.dll C:\local\private_symbols\VPhone.pdb
					ChkMatch - version 1.0
					Copyright (C) 2004 Oleg Starodumov
					http://www.debuginfo.com/
					
					
					Executable: C:\local\private_symbols\VPhone.dll
					Debug info file: C:\local\private_symbols\VPhone.pdb
					
					Executable:
					TimeDateStamp: 54fe67b0
					Debug info: 2 ( CodeView )
					TimeStamp: 54fe67b0  Characteristics: 0  MajorVer: 0  MinorVer: 0
					Size: 69  RVA: 006785d8  FileOffset: 006765d8
					CodeView format: RSDS
					Signature: {76a68cef-03b7-4ffe-867f-6ff5f86dda9a}  Age: 1
					PdbFile: D:\svn1\PaPhone4_win_code\Release\VPhone.pdb
					Debug info: 12 ( Unknown )
					TimeStamp: 54fe67b0  Characteristics: 0  MajorVer: 0  MinorVer: 0
					Size: 16  RVA: 00678620  FileOffset: 00676620
					
					Debug information file:
					Format: PDB 7.00
					Signature: {76a68cef-03b7-4ffe-867f-6ff5f86dda9a}  Age: 1
					
					Result: Matched						

			- 不匹配的情况

					C:\Users\wenw\Downloads\chkmatch>ChkMatch.exe -c C:\local\private_symbols\TrayDetour.dll C:\local\private_symbols\TrayDetour.pdb
					ChkMatch - version 1.0
					Copyright (C) 2004 Oleg Starodumov
					http://www.debuginfo.com/
					
					
					Executable: C:\local\private_symbols\TrayDetour.dll
					Debug info file: C:\local\private_symbols\TrayDetour.pdb
					
					Executable:
					TimeDateStamp: 53ba3918
					Debug info: 2 ( CodeView )
					TimeStamp: 53ba3918  Characteristics: 0  MajorVer: 0  MinorVer: 0
					Size: 106  RVA: 0000b4f0  FileOffset: 0000b4f0
					CodeView format: RSDS
					Signature: {a1919647-7daf-4abc-8c03-1bd1e7a4de9a}  Age: 10
					PdbFile: e:\workspace\projects\Ras\Ras_common\TrayDetour\TrayDetour\Release\TrayDetour.pdb
					
					Debug information file:
					Format: PDB 7.00
					Signature: {dd923c1a-69f2-4cb5-bfbf-5fca83cf690f}  Age: 1
					
					Result: Unmatched (reason: Signature mismatch)

		- 也可以用Debugging Tools for Windows自带的工具[symchk](https://msdn.microsoft.com/en-us/library/windows/hardware/ff558844(v=vs.85).aspx)，也可以参考[这里](https://msdn.microsoft.com/en-us/library/windows/desktop/ee416588(v=vs.85).aspx#check_if_a_given_dll_or_.exe_file_and_pdb_in_the_same_folder_match)的用法
			
			Check if a given DLL or .exe file and PDB in the same folder match
			
				"c:\Program Files\Debugging Tools for Windows\symchk" testing.dll /s
	
				SYMCHK: FAILED files = 0
				SYMCHK: PASSED + IGNORED files = 1

## 常见问题的排查思路（三板斧）

### Crash
- 确定异常类型，Crash大致有三种
	- 真正的Crash（SecondChance异常）：程序抛出未捕捉异常，进程崩溃退出
	- First Chance Exception：异常被捕捉到，进程没有退出
		- 部分应用程序会有自己的Application Log，可以看到Try/Catch逻辑中打出的Log，从而确认有FirstChance异常
		- 另一部分应用程序会借用Windows EventLog，把异常信息输出到Application EventLog中
	- 进程结束，但不是Crash，而是应用程序的代码逻辑自己结束了进程
- 收集Crash Dump
	- 对于SecondChance异常，直接收集Crash Dump
		- DebugDiag
		- Procdump
		- WER
	- 对于FirstChance异常，需要先确定异常类型（如果没有就收集所有的异常类型，收集10个）
		- DebugDiag
		- Procdump
	- 对于进程自行结束的，可以针对Terminate事件收集Dump
		- DebugDiag
		- Procdump
- 分析异常原因
	- .NET异常
		- 在StackObject或者GCHeap中找到异常对象
		- 打印Callstack，结合DSO和Review Code（SaveAllModule & ILSpy）
	- Native异常 
		- 找到异常抛出点
		- Callstack+传入参数+Symbol文件

### Hang
- 收集Hang Dump
	- 在进程Hang的时候，间隔10秒左右，手动敲命令收集，通常收集3个dump
	- 对于偶发性Hang，Hang时不方便手动收集的情况，可以设置DebugDiag或者Procdump规则，自动收集Dump。
- 分析Hang的原因
	- 对比Dump的Callstack，看Pending在哪些线程
	- 看`!lock`或者`!syncblk`，看是否有死锁现象
	- `!analyze -v hang`
- 常见的Hang原因
	- GC
	- 等WebService返回
	- 等DB返回
	- AsyncLock
	- SessionLock
	- 死锁

### High CPU
- 定位什么进程占用了主要的CPU资源
	- 性能计数器（Performance Counter）
	- 任务管理器（TaskManager）也可以，但它只能看当前时刻的情况，不能记录下趋势和时间的Map关系
- 定位什么线程占用了主要的CPU资源
	- 确定了哪一个进程之后，可以在问题发生时，间隔10秒左右，收集3个User Mode Dump
	- 收集Dump后通过`!runaway 3`找到各个线程的CPU占用时间
	- 比对收集时间相邻的Dump，可以找到CPU占用时间较多的线程是哪些
- 看哪些业务逻辑/代码消耗了这些CPU资源
	- 对Dump中（当前）占用CPU最多的线程，Dump Callstack，看问题发生时他们在执行什么代码
	- 将DLL Dump出来，反编译，Review源码
	- Research，看哪些Code Pattern可能造成CPU资源较高
	- Xperf 确认占用时间较多的函数
- 常见的Pattern
	- 频繁GC：GC Time超过15%
	- 正则表达式
	- 字符串处理
	- LINQ
	- 无阻塞的无限循环   

### Memory Leak
- 确定是不是Memory Leak
	- 服务进程业务量下降时，Memory是否会随之下降？
	- Tab或者WinForm窗口关闭时，客户端进程的Memory是否会随之下降？
	- 如果Memory只升不降，那么Memory Leak的可能性较大
- 对Memory Leak，收集Dump，分析Leak类型
	- 在Memory上升阶段，收集若干dump，比如1G/1.5G/2G
	- 如果不方便手动收集，可以编写脚本，用Procdump收集，或者DebugDiag
	- 分析Dump，可以看到内存增加的主要部分是什么
		- GC Heap
		- Dynamic Assembly
		- Native Heap
		- Native Unknown 
- 对Native Memory Leak，Hook Track Leak，收集Dump，分析原因
	- DebugDiag & TrackLeak.dll
	- 自动分析
		- DebugDiag Analysis

## 案例介绍

### Hang Case: 566733417260611
- Symptom
	- Windows service (AService.exe) will call an B.exe in background (session 0)
	- B.exe could work when run manually in cmd window
	- Windows service AService.exe could launch other exe in background without any hang

- Analysis
	- Repro issue, collect hang dump & procmon log
		- Download [procdump](https://technet.microsoft.com/en-us/sysinternals/dd996900.aspx)
		- Download [procmon](https://technet.microsoft.com/en-us/library/bb896645.aspx), Extract to `C:\mstrace` 
		- Open a cmd window as admin, run: 

				cd C:\mstrace 
				procmon /backingfile C:\mstrace\logfile.pml /AcceptEula /Minimized /Quiet 

		- Repro issue
		- Run command in cmd window: `procdump -ma -s 10 -n 3 <PID>`, for example:

				# <PID of AService.exe> = 2312
				procdump -ma -s 10 -n 3 2312

		- Run command to stop procmon: `procmon /terminate`
		- Collect dump & procmon logs, upload to our workspace.
		- Send B.exe to us, too.

	- Analyze Dump
		- Check Locks

				0:015> !locks
				Scanned 21 critical sections

			No locks, so diff callstack between 3 dumps.

		- Check callstack

				0:015> ~*kpnL		
				#  0  Id: 11f0.1138 Suspend: 0 Teb: 00007ff5`ff7de000 Unfrozen
				 # Child-SP          RetAddr           Call Site
				......
				06 000000c8`643ae860 00007ffc`e4110501 System_ServiceProcess_ni!System.ServiceProcess.ServiceBase.Run(<HRESULT 0x80004001>)+0x1fe
				07 000000c8`643ae8c0 00007ffd`43763753 AService!AOrg.WinEng.MyApps.Service.AService.Main(<HRESULT 0x80004001>)+0x81
				......
				0c 000000c8`643aeb20 00007ffd`438bf596 clr!RunMain(class MethodDesc * pFD = <Value unavailable error>, int * piRetVal = 0x000000c8`643aed50, class PtrArray ** stringArgs = 0x00000000`00000000)+0x1ba
				0d 000000c8`643aed00 00007ffd`438bf4d4 clr!Assembly::ExecuteMainMethod(class PtrArray ** stringArgs = 0x00000000`00000000)+0xba
				......
				
				   7  Id: 11f0.354 Suspend: 0 Teb: 00007ff5`ff5ea000 Unfrozen
				 # Child-SP          RetAddr           Call Site
				......
				08 000000c8`7ebadb60 00007ffd`41813b23 clr!ThreadNative::Join(class ThreadBaseObject * pThisUNSAFE = 0x000000c8`6542ad68, int Timeout = 0n-1)+0xec
				09 000000c8`7ebadcd0 00007ffd`418173ba System_ni!System.Diagnostics.ShellExecuteHelper.ShellExecuteOnSTAThread(<HRESULT 0x80004001>)+0x93
				0a 000000c8`7ebadd10 00007ffd`41844e9c System_ni!System.Diagnostics.Process.StartWithShellExecuteEx(<HRESULT 0x80004001>)+0x23a
				0b 000000c8`7ebadd60 00007ffc`e49f071d System_ni!System.Diagnostics.Process.Start(<HRESULT 0x80004001>)+0x3c
				0c 000000c8`7ebadda0 00007ffc`e49e4c03 Common!AOrg.WinEng.MyInstaller.Scripts.InstallerContext.LaunchReporter(<HRESULT 0x80004001>)+0x17d
				0d 000000c8`7ebade30 00007ffc`e49e44e3 Common!AOrg.WinEng.MyInstaller.Scripts.InstallerContext+<Execute>d__78.MoveNext(<HRESULT 0x80004001>)+0x1183
				0e 000000c8`7ebade80 00007ffd`42622490 Common!AOrg.WinEng.MyInstaller.Scripts.InstallerContext+<Execute>d__78.MoveNext(<HRESULT 0x80004001>)+0xa63
				......
				24 000000c8`7ebaea60 00007ffd`4268db68 mscorlib_ni!System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(<HRESULT 0x80004001>)+0x62
				25 000000c8`7ebaeab0 00007ffd`4268d646 mscorlib_ni!System.Threading.Tasks.Task.FinishContinuations(<HRESULT 0x80004001>)+0x458
				26 000000c8`7ebaeb40 00007ffd`4268d5c4 mscorlib_ni!System.Threading.Tasks.Task`1[[System.__Canon, mscorlib]].TrySetResult(<HRESULT 0x80004001>)+0x66
				27 000000c8`7ebaeb80 00007ffc`e4970392 mscorlib_ni!System.Threading.Tasks.TaskCompletionSource`1[[System.__Canon, mscorlib]].TrySetResult(<HRESULT 0x80004001>)+0x14
				28 000000c8`7ebaebc0 00007ffc`e496ed33 Microsoft_AspNet_SignalR_Client!Microsoft.AspNet.SignalR.Client.Hubs.HubProxy+<>c__DisplayClass5`2[[System.__Canon, mscorlib],[System.__Canon, mscorlib]].<Invoke>b__3(<HRESULT 0x80004001>)+0x2f2
				29 000000c8`7ebaec50 00007ffc`e496ea3d Microsoft_AspNet_SignalR_Client!Microsoft.AspNet.SignalR.Client.HubConnection.OnMessageReceived(<HRESULT 0x80004001>)+0x2a3
				2a 000000c8`7ebaed40 00007ffd`426aaf17 Microsoft_AspNet_SignalR_Client!Microsoft.AspNet.SignalR.Client.Connection+<>c__DisplayClassd.<Microsoft.AspNet.SignalR.Client.IConnection.OnReceived>b__c(<HRESULT 0x80004001>)+0x2d
				2b 000000c8`7ebaed80 00007ffd`42622490 mscorlib_ni!System.Threading.Tasks.Task.Execute(<HRESULT 0x80004001>)+0x47
				......
				
				  15  Id: 11f0.ec8 Suspend: 0 Teb: 00007ff5`ff5f8000 Unfrozen
				 # Child-SP          RetAddr           Call Site
				00 000000c8`00fdc0a8 00007ffd`4cd554fb user32!ZwUserWaitMessage(void)+0xa
				01 000000c8`00fdc0b0 00007ffd`4cd58ae2 user32!DialogBox2(struct HWND__ * hwnd = 0x00000000`0005008c, struct HWND__ * hwndOwner = 0x00000000`00000000, int fDisabled = <Value unavailable error>, int fOwnerIsActiveWindow = <Value unavailable error>)+0x212
				02 000000c8`00fdc140 00007ffd`4cd58ba6 user32!InternalDialogBox(void * hModule = 0x00007ffd`2f0e0000, struct DLGTEMPLATE * lpdt = 0x000000c8`010005a0, struct HWND__ * hwndOwner = 0x00000000`00000000, <function> * pfnDialog = 0x00007ffd`2f0ebae0, int64 lParam = 0n859010090000, unsigned int fSCDLGFlags = 1)+0x132
				03 000000c8`00fdc1a0 00007ffd`4cd59025 user32!DialogBoxIndirectParamAorW(struct HINSTANCE__ * hmod = 0x00007ffd`2f0e0000, struct DLGTEMPLATE * lpDlgTemplate = 0x000000c8`010005a0, struct HWND__ * hwndOwner = 0x00000000`00000000, <function> * lpDialogFunc = 0x00007ffd`2f0ebae0, int64 dwInitParam = 0n859010090000, unsigned int fAnsiFlags = 0)+0x56
				04 000000c8`00fdc1e0 00007ffd`2f0f3bdd user32!DialogBoxParamW(struct HINSTANCE__ * hmod = 0x00007ffd`2f0e0000, wchar_t * lpName = 0x00000000`00001140 "--- memory read error at address 0x00000000`00001140 ---", struct HWND__ * hwndOwner = 0x00000000`00000000, <function> * lpDialogFunc = 0x00007ffd`2f0ebae0, int64 dwInitParam = 0n859010090000)+0x85
				05 000000c8`00fdc230 00007ffd`2f0eca74 shdocvw!SHFusionDialogBoxParam(struct HINSTANCE__ * hInstance = 0x00007ffd`2f0e0000, wchar_t * lpTemplateName = 0x00000000`00001140 "--- memory read error at address 0x00000000`00001140 ---", struct HWND__ * hWndParent = 0x00000000`00000000, <function> * lpDialogFunc = 0x00007ffd`2f0ebae0, int64 dwInitParam = 0n859010090000)+0x61
				06 000000c8`00fdc280 00007ffd`2f0ed592 shdocvw!_ShowSafeOpenDialog(struct HWND__ * hwnd = <Value unavailable error>, struct SAFEOPENDLGPARAM * pparam = <Value unavailable error>)+0x24
				07 000000c8`00fdc2c0 00007ffd`4b038526 shdocvw!SafeOpenPromptForShellExec(struct HWND__ * hwnd = <Value unavailable error>, wchar_t * pszFile = 0x000000c8`7e336498 "\\ShareFolder\apps\AOrg\WinEng\SoftwareDelivery\MyAppsReporting\B.exe\1.0\B.exe")+0x6c2
				08 000000c8`00fde790 00007ffd`4ac44450 shell32!CInvokeCreateProcessVerb::_ZoneCheckFile+0x3f40b6
				09 000000c8`00fde800 00007ffd`4ac44339 shell32!CInvokeCreateProcessVerb::_VerifyZoneTrust(wchar_t * pszFile = 0x000000c8`7e336498 "\\ShareFolder\apps\AOrg\WinEng\SoftwareDelivery\MyAppsReporting\B\1.0\B.exe")+0x24
				0a 000000c8`00fde830 00007ffd`4ac426a0 shell32!CInvokeCreateProcessVerb::_VerifyExecTrust(void)+0xc5
				0b 000000c8`00fde880 00007ffd`4ac450c3 shell32!CInvokeCreateProcessVerb::Execute(void)+0x30
				......
				15 000000c8`00fdec30 00007ffd`42622490 System_ni!System.Diagnostics.ShellExecuteHelper.ShellExecuteFunction(<HRESULT 0x80004001>)+0x11
				16 000000c8`00fdec60 00007ffd`42622327 mscorlib_ni!
				......
				24 000000c8`00fdf490 00007ffd`43783e1e clr!ThreadNative::KickOffThread(void * pass = 0x000000c8`00331b30)+0x16f
				......

	- In thread 15, we could find:
		- the launched exe is: `\\ShareFolder\apps\AOrg\WinEng\SoftwareDelivery\MyAppsReporting\B\1.0\B.exe`
		- there was a DialogBox popup, which is not correct, since DialogBox in background will hang the service process.

				0:015> kL10
				 # Child-SP          RetAddr           Call Site
				00 000000c8`00fdc0a8 00007ffd`4cd554fb user32!ZwUserWaitMessage+0xa
				01 000000c8`00fdc0b0 00007ffd`4cd58ae2 user32!DialogBox2+0x212
				02 000000c8`00fdc140 00007ffd`4cd58ba6 user32!InternalDialogBox+0x132
				03 000000c8`00fdc1a0 00007ffd`4cd59025 user32!DialogBoxIndirectParamAorW+0x56
				04 000000c8`00fdc1e0 00007ffd`2f0f3bdd user32!DialogBoxParamW+0x85
				05 000000c8`00fdc230 00007ffd`2f0eca74 shdocvw!SHFusionDialogBoxParam+0x61
				06 000000c8`00fdc280 00007ffd`2f0ed592 shdocvw!_ShowSafeOpenDialog+0x24
				07 000000c8`00fdc2c0 00007ffd`4b038526 shdocvw!SafeOpenPromptForShellExec+0x6c2
				08 000000c8`00fde790 00007ffd`4ac44450 shell32!CInvokeCreateProcessVerb::_ZoneCheckFile+0x3f40b6
				09 000000c8`00fde800 00007ffd`4ac44339 shell32!CInvokeCreateProcessVerb::_VerifyZoneTrust+0x24
				0a 000000c8`00fde830 00007ffd`4ac426a0 shell32!CInvokeCreateProcessVerb::_VerifyExecTrust+0xc5
				0b 000000c8`00fde880 00007ffd`4ac450c3 shell32!CInvokeCreateProcessVerb::Execute+0x30
				0c 000000c8`00fde8b0 00007ffd`4ac42885 shell32!CBindAndInvokeStaticVerb::_DoCommand+0x123
				0d 000000c8`00fde930 00007ffd`4ac45212 shell32!CBindAndInvokeStaticVerb::_TryCreateProcessDdeHandler+0x4d
				0e 000000c8`00fde960 00007ffd`4ac41d2a shell32!CBindAndInvokeStaticVerb::Execute+0xf7
				0f 000000c8`00fdea10 00007ffd`4ac408e5 shell32!CShellExecute::_ExecuteAssoc+0x11a
				
				0:015> dx Debugger.Sessions[0].Processes[4592].Threads[3784].Stack.Frames[1].SwitchTo();dv /t /v
				Debugger.Sessions[0].Processes[4592].Threads[3784].Stack.Frames[1].SwitchTo()
				@rdi              struct HWND__ * hwnd = 0x00000000`0005008c
				@rbx              struct HWND__ * hwndOwner = 0x00000000`00000000
				<unavailable>     int fDisabled = <value unavailable>
				<unavailable>     int fOwnerIsActiveWindow = <value unavailable>
				<unavailable>     int fWantIdleMsgs = <value unavailable>
				<unavailable>     int64 result = <value unavailable>
				@r14d             int fShown = 0n1
				@r15d             int fSentIdleMessage = 0n0
				000000c8`00fdc0e0 struct tagMSG msg = {msg=0x1e00d6 wp=0x3043394a4aee lp=0x5000}
				<unavailable>     struct HWND__ * hwndCapture = <value unavailable>
				@rbp              struct tagWND * pwnd = 0x000000c8`645be0b0
				
				0:015> !userexts.dw -v hwnd 0x00000000`0005008c 
				pwnd    = 0x000000c8645be0b0
					handle             0x000000000005008c
					spwndNext          0xfffff90141c062f0     "Wmi Provider Host"
					spwndPrev          0xfffff90141c0b4b0     "Wmi Provider Host"
					spwndParent        0xfffff90141c00830     "<null>"
					spwndChild         0xfffff90141c09280     "We can¡¯t verify who created this file. Are you sure you want to run this file?"
					spwndOwner         0x0000000000000000     ""
					rcWindow           (272,229)-(752,538) 480x309
					rcClient           (280,260)-(744,530) 464x270
					lpfnWndProc        0x00007ffd4d600480     (ntdll!NtdllDialogWndProc_W) Unicode
					pcls               0x000000c8645bb9e0     (V):0x8002     (NV):0x8002     Name:"#32770"
					hrgnUpdate         0x0000000000000000
					spwndLastActive    0xfffff90141c0e0b0     "Open File - Security Warning"
					ppropList          0xfffff90141c0d1c0
					pSBInfo            0x0000000000000000
					spmenuSys          0xfffff90141c0b660
					spmenu/id          0x0000000000000000
					hrgnClip           0x0000000000000000
					pName              "Open File - Security Warning"
					......
	
		- So, thread 15 hang due to B.exe came from net share
	- Check thread 7, it wait for thread join()
		- Callstack

				7  Id: 11f0.354 Suspend: 0 Teb: 00007ff5`ff5ea000 Unfrozen
				 # Child-SP          RetAddr           Call Site
				00 000000c8`7ebad568 00007ffd`4a9013ed ntdll!ZwWaitForMultipleObjects(void)+0xa
				01 000000c8`7ebad570 00007ffd`438392aa KERNELBASE!WaitForMultipleObjectsEx(unsigned long nCount = 1, void ** lpHandles = <Value unavailable error>, int bWaitAll = 0n0, unsigned long dwMilliseconds = 0, int bAlertable = 0n1)+0xe1
				02 000000c8`7ebad850 00007ffd`438391bf clr!WaitForMultipleObjectsEx_SO_TOLERANT(unsigned long nCount = 1, void ** lpHandles = 0x000000c8`7ebadae8, int bWaitAll = 0n0, unsigned long dwMilliseconds = 0xffffffff, int bAlertable = 0n1)+0x62
				03 (Inline Function) --------`-------- clr!Thread::DoAppropriateAptStateWait+0x44
				04 000000c8`7ebad8b0 00007ffd`43838fb1 clr!Thread::DoAppropriateWaitWorker(int countHandles = 0n1, void ** handles = 0x000000c8`7ebadae8, int waitAll = 0n0, unsigned long millis = 0xffffffff, WaitMode mode = WaitMode_Alertable (0n1))+0x243
				05 000000c8`7ebad9b0 00007ffd`43ae5b6b clr!Thread::DoAppropriateWait(int countHandles = 0n1, void ** handles = 0x000000c8`7dadbd88, int waitAll = 0n1136730664, unsigned long millis = 0xffffffff, WaitMode mode = WaitMode_Alertable (0n1), struct PendingSync * syncState = 0x00000000`00000000)+0x7d
				06 000000c8`7ebada30 00007ffd`43c0f06a clr!Thread::JoinEx(unsigned long timeout = 0xffffffff, WaitMode mode = WaitMode_Alertable (0n1))+0xeb
				07 000000c8`7ebadad0 00007ffd`43c10998 clr!ThreadNative::DoJoin(class ThreadBaseObject * DyingThread = <Value unavailable error>, int timeout = <Value unavailable error>)+0xfe
				08 000000c8`7ebadb60 00007ffd`41813b23 clr!ThreadNative::Join(class ThreadBaseObject * pThisUNSAFE = 0x000000c8`6542ad68, int Timeout = 0n-1)+0xec
				09 000000c8`7ebadcd0 00007ffd`418173ba System_ni!System.Diagnostics.ShellExecuteHelper.ShellExecuteOnSTAThread(<HRESULT 0x80004001>)+0x93
				0a 000000c8`7ebadd10 00007ffd`41844e9c System_ni!System.Diagnostics.Process.StartWithShellExecuteEx(<HRESULT 0x80004001>)+0x23a
				0b 000000c8`7ebadd60 00007ffc`e49f071d System_ni!System.Diagnostics.Process.Start(<HRESULT 0x80004001>)+0x3c
				0c 000000c8`7ebadda0 00007ffc`e49e4c03 Common!AOrg.WinEng.MyInstaller.Scripts.InstallerContext.LaunchReporter(<HRESULT 0x80004001>)+0x17d
				0d 000000c8`7ebade30 00007ffc`e49e44e3 Common!AOrg.WinEng.MyInstaller.Scripts.InstallerContext+<Execute>d__78.MoveNext(<HRESULT 0x80004001>)+0x1183
				0e 000000c8`7ebade80 00007ffd`42622490 Common!AOrg.WinEng.MyInstaller.Scripts.InstallerContext+<Execute>d__78.MoveNext(<HRESULT 0x80004001>)+0xa63
				0f 000000c8`7ebae1b0 00007ffd`42622327 mscorlib_ni!System.Threading.ExecutionContext.RunInternal(<HRESULT 0x80004001>)+0x160

				0:007> lmvm Common
				Browse full module list
				start             end                 module name
				000000c8`7d4d0000 000000c8`7d504000   Common   C (no symbols)           
				    Loaded symbol image file: Common.dll
				    ......

		- Dump Common.dll & reflect: `!mex.writemodule -a -p C:\test4444444`

				// Aorg.WinEng.MyInstaller.Scripts.InstallerContext
				private static void LaunchReporter()
				{
					ProcessStartInfo processStartInfo = new ProcessStartInfo
					{
						FileName = Variables.BPath,
						Arguments = "/svc-env PROD",
						UseShellExecute = true,
						CreateNoWindow = true,
						WindowStyle = ProcessWindowStyle.Hidden
					};
					bool flag = !File.Exists(processStartInfo.FileName);
					if (flag)
					{
						Log.Debug(string.Format("Error to load B {0}", processStartInfo.FileName));
						throw new Exception("B can't find!");
					}
					Process.Start(processStartInfo);
				}

		- Reflect ShellExecuteHelper， start thread then join

				// System.Diagnostics.ShellExecuteHelper
				public bool ShellExecuteOnSTAThread()
				{
					if (Thread.CurrentThread.GetApartmentState() != ApartmentState.STA)
					{
						Thread expr_1D = new Thread(new ThreadStart(this.ShellExecuteFunction));
						expr_1D.SetApartmentState(ApartmentState.STA);
						expr_1D.Start();
						expr_1D.Join();
					}
					else
					{
						this.ShellExecuteFunction();
					}
					return this._succeeded;
				}

- Conclusion
	- DialogBox popup due to B.exe not trust (in share folder)
	- DialogBox hang AService.exe
 
- Solution
	- We could try move B.exe to local machine
	- Or, we could signature B.exe, refer to [MSDN Blog](https://blogs.msdn.microsoft.com/ieinternals/2011/03/22/everything-you-need-to-know-about-authenticode-code-signing/)
	- Or, we could diable security check, refer to [Technet](https://technet.microsoft.com/en-us/library/bb496428.aspx?f=255&MSPPError=-2147217396), or [blog](http://www.technipages.com/fix-we-cant-verify-who-created-this-file-error)

### Crash