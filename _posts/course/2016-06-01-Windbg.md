---
layout:         post
title:          Debug-Windbg
category:       course
description:    本文介绍：Windbg的基本功能，常用的插件和命令，以及Windbg在实际案例中的应用。
---

## QuickStart

### 简介

Windbg是Windows平台上的Debug Tool，Unix/Linux世界中功能类似的产品是GDB。WinDbg作为免费的Debugging Tools for Windows包的组成部分被发行（Windbg还有一个Internal Usage的版本，功能更为强大）。WinDbg是有GUI界面的，但它与命令行调试器前端如KD，CDB，NTSD共享了一个调试器后端。

Windbg的功能包括：

- Windbg分为开放版本和内部版本。
- 可用于调试用户态下的应用程序、以及核心态下的驱动程序和操作系统自身。
- 可用于在线的Live Debug或者离线Debug（Memory Dump / TTTracing）
- WinDbg能从服务器自动装载匹配的调试符号文件，如PDB文件。调试符号文件在源代码文件与二进制可执行程序之间创建对应关系。Microsoft的公开的（PDB文件也有Private版本，Private Symbol提供了更详细的信息）符号服务器提供了Windows 2000以后各版本操作系统及服务包的绝大部分符号。

### Install & Config

- Install
	- Public Download [Get Debugging Tools for Windows (WinDbg) (from the SDK)](https://go.microsoft.com/fwlink/p/?LinkId=536682)
	- [Internal Version](http://sharepoint/sites/debug/Tips/Windows%20Debugger.aspx)，或者这个链接：http://debug。别费力气了，非微软员工账号或者在外网都访问不了的。`\\dbg\privates\latest\`，可以直接到这里下载。
	- `dbg_x86.msi`和`dbg_amd64.msi`都装上，分别用于Debug 32bit和64bit进程。安装路径分别是：`C:\Debugger`和`C:\Debugger64`
	- 自动化Dump分析工具也推荐安装：
		- [Matlas](http://toolbox/MAtlas)，MS Internal Usage
		- [DebugDiag2.2](https://www.microsoft.com/en-us/download/details.aspx?id=49924), for Vista+
		- [DebugDiag1.2](https://www.microsoft.com/en-us/download/details.aspx?id=26798), for XP or 2003
- Config
	- Setup symbol path and extension path for WinDBG

		We will add the following environment variables to system to system variables, then you don't need to set them for each debugging session.
     
		![environmenVariable.png](http://7xudfs.com1.z0.glb.clouddn.com/c357331791434ffe98d84126ee441091-environmenVariable.png)
		
		这里设置了两个环境变量：`_NT_SYMBOL_PATH`和`_NT_DEBUGGER_EXTENSION_PATH`。其实`_NT_DEBUGGER_EXTENSION_PATH`不建议设置，因为extension 64bit/32bit不兼容的。推荐将64bit的extenstion直接添加到Windbg 64bit安装目录的winext目录中，将32bit的extenstion直接添加到Windbg 32bit安装目录的winext目录中.

	- Symbol Path
		- Internal的Symbol Path是：
				
				cache*c:\symbols;srv*http://symweb
				# 或者长这样
				cache*c:\symbols;srv*http://symweb;SRV*\\gcrcssfs\Products\Symbols
				SRV*d:\SymCache*http://symweb;SRV*\\gcrcssfs\Products\Symbols
				srv*\\sha-fs-01a\DSI\DSI-Symbol-Share\Symbol*http://symweb
				cache*c:\symbols;srv*\\sha-fs-01a\DSI\DSI-Symbol-Share\Symbol*http://symweb

		- Public Symbol Server (Microsoft)：
			
				srv*c:\mss*http://msdl.microsoft.com/download/symbols
		- Public Symbol Server (Citrix)：	

				srv*c:\css*http://ctxsym.citrix.com/symbols
		- 动态配置Symbol的命令：
		
				.symfix c:\mss
				.sympath+ srv*c:\css*http://ctxsym.citrix.com/symbols

### Common Usage

- Attach Process
- Attach Process on launch
- Open Crash Dump & Analysis
- Open TTTracing & Analysis

### Windbg Reference

- [MSDN](https://msdn.microsoft.com/en-us/library/windows/hardware/ff551063(v=vs.85).aspx)
- [windbg.org](http://www.windbg.org/)
- [QuickStart](https://msdn.microsoft.com/en-us/library/windows/hardware/dn745911(v=vs.85).aspx)
- [windbg.info](http://www.windbg.info/)

## 基本命令

### Command Reference
- Windbg.ino: [Common Commands](http://www.windbg.info/doc/1-common-cmds.html), also you could download: [PDF](http://www.windbg.info/download/doc/pdf/WinDbg_cmds.pdf)
- 练习工具: [CrashMe](http://www.windbg.info/apps/46-crashme.html)

### Command Details
- 一招鲜命令
	- `.time`：当前时间，系统和进程运行了多长时间
	- `!dml_proc`：进程PID
	- `!cl`：Command Line
	- `lm`：列出所有dll，`lmvm clr`：查看clr dll的信息
	- `vertarget`：看target系统信息，`version`：target和debugger两者的信息
	- `~`：列出所有的线程（可以看系统线程号和进程内线程号对应关系）
	- `~1s`：切换到1号线程（进程内Thread ID）
- `!userexts.dw -aefhvsprwoz [hwnd/pwnd]`: Displays information on windows in system

		struct HWND__ * hwnd = 0x00000000`0005008c
		!userexts.dw -v hwnd 0x00000000`0005008c 

- `d`命令：
	- `df`
	- `dt`：根据Type打印对象

			0:015> dt  000000c8`00fdc0e0 tagMSG
			  shdocvw!tagMSG
			     +0x000 hwnd             : 0x00880028`50010000 HWND__
			     +0x008 message          : 0x1e00d6
			     +0x010 wParam           : 0x00003043`394a4aee
			     +0x018 lParam           : 0n20480
			     +0x020 time             : 0x2f0e0000
			     +0x024 pt               : tagPOINT

	- `dx`
		
			0:015> dx -r1 -n (*((user32!tagMSG *)0xc800fdc0e0))
			(*((user32!tagMSG *)0xc800fdc0e0)) : {msg=0x1e00d6 wp=0x3043394a4aee lp=0x5000} [Type: tagMSG]
		      [+0x000] hwnd             : 0x88002850010000 [Type: HWND__ *]
		      [+0x008] message          : 0x1e00d6 [Type: unsigned int]
		      [+0x010] wParam           : 0x3043394a4aee [Type: unsigned __int64]
		      [+0x018] lParam           : 20480 [Type: __int64]
		      [+0x020] time             : 0x2f0e0000 [Type: unsigned long]
		      [+0x024] pt               [Type: tagPOINT]

- `x`：查看一个模块里的方法

		 x /D /f icbccertenroll!a*

- `!userexts.dw -v hwnd 0x000000000005008c`：查看HWND对象

		struct HWND__ * hwnd = 0x00000000`0005008c
		!userexts.dw -v hwnd 0x00000000`0005008c 
		  pwnd    = 0x000000c8645be0b0
		      handle             0x000000000005008c
		      ......
		      spwndChild         0xfffff90141c09280     "We can¡¯t verify who created this file. Are you sure you want to run this file?"
		      ......
		      pName              "Open File - Security Warning"

- `!psscor2.eeheap -gc`：看.NET GC中各Heap的大小以及总体
- `!mex.gcheapinfo`
- `!mex.strings 30b40000 31440000` 
- `!dumpheap -stat`：看.NET GC中各对象的统计
- `!gchandles`：查看GC Handler信息
- `!address -summray`
	- `!address -f:PageHeap`
	- `!address -f:MEM_COMMIT`
	- `!address -f:MEM_FREE`
	- `!address -f:MEM_PRIVATE`
	- `!address -f:Image`
	- `!address -f:Unk`
- `!heap -stat`
	- `!heap -stat -h 00150000`

			0:000> !heap -stat -h 00150000
			heap @ 00150000
			group-by: TOTSIZE max-display: 20
			    size     #blocks     total     ( %) (percent of total busy bytes)
			    fff8 3b - 3afe28  (14.30)
			    1ff8 1d1 - 3a1178  (14.08)
			
			0:000> !heap -flt s fff8
		    _HEAP @ 150000
		      HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state			        
		        0be0ec40 2000 2000  [01]   0be0ec48    0fff8 - (busy)
		        0c689440 2000 2000  [00]   0c689448    0fff8 - (free)

			0:000> df 0be0ec40 
			0be0ec40    9.4131384e-038   2.4980026e-038    4.565969e-035   4.5327062e-035
			0be0ec50    2.2420775e-044  -5.5661604e+029  -5.0347669e+026  -1.8609711e+038
			0be0ec60     8.625787e-032   8.6761451e-032   1.8438986e-040   1.6815582e-044
			0be0ec70    1.4012985e-045   1.3592595e-043   1.4012985e-045   8.6643173e-032

## 常用插件

### sos

### sosext

### psscor2/psscor4

### mex

### iisinfo

## 常用技巧

### Save Modules from Dump
- 保存单个DLL
	- 参考：[Commands to ListExtract dlls from Memory Dump using WinDbg](https://blogs.technet.microsoft.com/sateesh-arveti/2012/02/09/commands-to-listextract-dlls-from-memory-dump-using-windbg/)
	- `kML`看模块名称
	- `lmvm <模块名称>`，找到起始地址（比如：00040026）
	- `!SaveModule 00040026 c:\test.dll`
	- 用ILSpy反编译Managed DLL来Review Code
- 保存所有DLL
	- `!psscor4.sam d:\moduleFolder`
	- `!mex.writemodule -a -p d:\moduleFolder\`，目录 **d:\moduleFolder** 需要提前创建好。
	- Matlas
		
		![Matlas-SAM.png](http://7xudfs.com1.z0.glb.clouddn.com/ebae808f8441465a8cc2c68ae985ef60-Matlas-SAM.png)

### 加载Private Symbol
- 何时需要手动加载Private Symbol

	如果在分析Dump时，打印callstack出现如下现象，说明我们的Debugger没有找到这个Assembly对应的symbol文件（PDB文件），此时我们需要手动加载Private Symbol。

		0:001> kL
		 # ChildEBP RetAddr  
		00 0253f988 10001861 ws2_32!recvfrom+0xd1
		WARNING: Stack unwind information not available. Following frames may be wrong.
		01 0253ff88 771a3677 TrayDetour+0x1861
		02 0253ff94 77a59d72 kernel32!BaseThreadInitThunk+0xe
		03 0253ffd4 77a59d45 ntdll!__RtlUserThreadStart+0x70
		04 0253ffec 00000000 ntdll!_RtlUserThreadStart+0x1b

	上文中可以看到：**WARNING: Stack unwind information not available. Following frames may be wrong.**，同时随后的**TrayDetour+0x1861**，说明我们没有找到TrayDetour模块的pdb文件，需要手动加载

- 加载步骤
	- 将dll和pdb文件拷贝到一起
	- Windbg中输入`.sympath+"C:\local\private_symbols"`命令，**珍爱生命，远离下划线，新版本的Windbg竟然有下划线（private_symbol）加载失败，心塞。下次遇到失败时，试试把路径改成`C:\local`**，添加symbol文件路径：`C:\local\private_symbols`
	
			0:015> .sympath+"C:\local\private_symbols"
			Symbol search path is: cache*c:\symbols;srv*http://symweb;C:\local\private_symbols
			Expanded Symbol search path is: cache*c:\symbols;srv*http://symweb;c:\local\private_symbols
			
			************* Symbol Path validation summary **************
			Response                         Time (ms)     Location
			Deferred                                       cache*c:\symbols
			Deferred                                       srv*http://xxxx
			OK                                             C:\local\private_symbols

	- Windbg中输入`.reload /f VPhone.dll`命令，加载symbol
	
			0:015> .reload /f VPhone.dll
			*** WARNING: Unable to verify checksum for VPhone.dll
			0:015> kL
			 # ChildEBP RetAddr  
			00 0841c5f0 76e56a44 ntdll!KiFastSystemCallRet
			.....
			0d 0841c89c 76e2f987 ntdll!ExecuteHandler+0x24
			0e 0841c928 76e57057 ntdll!RtlDispatchException+0x127
			0f 0841c928 591690f2 ntdll!KiUserExceptionDispatcher+0xf
			10 0841cd90 59166f98 VPhone!CBitmap::CreateCompatibleBitmap+0x12
			11 0841ce40 59557062 VPhone!CPhoneButton::DrawItem+0x168
			12 0841ce4c 5955042e VPhone!CStatic::OnChildNotify+0x1a
			......
	
	- 如果symbol文件和Assembly不匹配，会加载不成功

			0:001> .reload /f TrayDetour.dll
			*** WARNING: Unable to verify checksum for TrayDetour.dll
			*** ERROR: Symbol file could not be found.  Defaulted to export symbols for TrayDetour.dll - 
			
			************* Symbol Loading Error Summary **************
			Module name            Error
			TrayDetour             PDB not found : cache*c:\symbols
			                       The server has never indexed the given version of the given file : srv*http://xxxx
			                       The system cannot find the file specified : c:\local\private_symbols
			                       Signature does not match : c:\symbols\TrayDetour.pdb\DD923C1A69F24CB5BFBF5FCA83CF690F1\TrayDetour.pdb
			
			The following location did not respond and were excluded during symbol loading:
			srv*\\gcrcssfs\products\symbols
			
			You can troubleshoot most symbol related issues by turning on symbol loading diagnostics (!sym noisy) and repeating the command that caused symbols to be loaded.
			You should also verify that your symbol search path (.sympath) is correct.
	
		这里给出了加载pdb文件失败的原因：**Signature does not match**

	- 如何验证symbol文件和Assembly是否匹配
		- 可以用[Chkmatch](http://www.debuginfo.com/tools/chkmatch.html)工具
			- 命令：

					ChkMatch.exe -c C:\local\private_symbols\VPhone.dll C:\local\private_symbols\VPhone.pdb

			- 匹配的情况

					C:\Users\wenw\Downloads\chkmatch>ChkMatch.exe -c C:\local\private_symbols\VPhone.dll C:\local\private_symbols\VPhone.pdb
					ChkMatch - version 1.0
					Copyright (C) 2004 Oleg Starodumov
					http://www.debuginfo.com/
					
					
					Executable: C:\local\private_symbols\VPhone.dll
					Debug info file: C:\local\private_symbols\VPhone.pdb
					
					Executable:
					TimeDateStamp: 54fe67b0
					Debug info: 2 ( CodeView )
					TimeStamp: 54fe67b0  Characteristics: 0  MajorVer: 0  MinorVer: 0
					Size: 69  RVA: 006785d8  FileOffset: 006765d8
					CodeView format: RSDS
					Signature: {76a68cef-03b7-4ffe-867f-6ff5f86dda9a}  Age: 1
					PdbFile: D:\svn1\PaPhone4_win_code\Release\VPhone.pdb
					Debug info: 12 ( Unknown )
					TimeStamp: 54fe67b0  Characteristics: 0  MajorVer: 0  MinorVer: 0
					Size: 16  RVA: 00678620  FileOffset: 00676620
					
					Debug information file:
					Format: PDB 7.00
					Signature: {76a68cef-03b7-4ffe-867f-6ff5f86dda9a}  Age: 1
					
					Result: Matched						

			- 不匹配的情况

					C:\Users\wenw\Downloads\chkmatch>ChkMatch.exe -c C:\local\private_symbols\TrayDetour.dll C:\local\private_symbols\TrayDetour.pdb
					ChkMatch - version 1.0
					Copyright (C) 2004 Oleg Starodumov
					http://www.debuginfo.com/
					
					
					Executable: C:\local\private_symbols\TrayDetour.dll
					Debug info file: C:\local\private_symbols\TrayDetour.pdb
					
					Executable:
					TimeDateStamp: 53ba3918
					Debug info: 2 ( CodeView )
					TimeStamp: 53ba3918  Characteristics: 0  MajorVer: 0  MinorVer: 0
					Size: 106  RVA: 0000b4f0  FileOffset: 0000b4f0
					CodeView format: RSDS
					Signature: {a1919647-7daf-4abc-8c03-1bd1e7a4de9a}  Age: 10
					PdbFile: e:\workspace\projects\Ras\Ras_common\TrayDetour\TrayDetour\Release\TrayDetour.pdb
					
					Debug information file:
					Format: PDB 7.00
					Signature: {dd923c1a-69f2-4cb5-bfbf-5fca83cf690f}  Age: 1
					
					Result: Unmatched (reason: Signature mismatch)

		- 也可以用Debugging Tools for Windows自带的工具[symchk](https://msdn.microsoft.com/en-us/library/windows/hardware/ff558844(v=vs.85).aspx)，也可以参考[这里](https://msdn.microsoft.com/en-us/library/windows/desktop/ee416588(v=vs.85).aspx#check_if_a_given_dll_or_.exe_file_and_pdb_in_the_same_folder_match)的用法
			
			Check if a given DLL or .exe file and PDB in the same folder match
			
				"c:\Program Files\Debugging Tools for Windows\symchk" testing.dll /s
	
				SYMCHK: FAILED files = 0
				SYMCHK: PASSED + IGNORED files = 1

### 判断Assembly的CPU-Arch类型
- 用一个Perl脚本可以安全做到，参考[stackoverflow](http://stackoverflow.com/questions/495244/how-can-i-test-a-windows-dll-to-determine-if-it-is-32bit-or-64bit)

		pear@mgt:~/hubWarehouse$ perl a.perl /samba/share/GSClientSet.dll
		i386

		pear@mgt:~/hubWarehouse$ cat a.perl
		#!/usr/bin/perl
		#
		# usage: petype <exefile>
		#
		$exe = $ARGV[0];
		
		open(EXE, $exe) or die "can't open $exe: $!";
		binmode(EXE);
		if (read(EXE, $doshdr, 68)) {
		
		   ($magic,$skip,$offset)=unpack('a2a58l', $doshdr);
		   die("Not an executable") if ($magic ne 'MZ');
		
		   seek(EXE,$offset,SEEK_SET);
		   if (read(EXE, $pehdr, 6)){
		       ($sig,$skip,$machine)=unpack('a2a2v', $pehdr);
		       die("No a PE Executable") if ($sig ne 'PE');
		
		       if ($machine == 0x014c){
		            print "i386\n";
		       }
		       elsif ($machine == 0x0200){
		            print "IA64\n";
		       }
		       elsif ($machine == 0x8664){
		            print "AMD64\n";
		       }
		       else{
		            printf("Unknown machine type 0x%lx\n", $machine);
		       }
		   }
		}
		
		close(EXE);


- 用Dumpbin也可以做到：`dumpbin /headers printCtl4RA.dll`

	![VS-Dev-Cmd-Prompt.png](http://7xudfs.com1.z0.glb.clouddn.com/c357331791434ffe98d84126ee441091-VS-Dev-Cmd-Prompt.png)

		Microsoft (R) COFF/PE Dumper Version 14.00.23918.0
		Copyright (C) Microsoft Corporation.  All rights reserved.

		Dump of file printCtl4RA.dll
		PE signature found
		File Type: DLL
		FILE HEADER VALUES
             14C machine (x86)
               5 number of sections

### 检查Assembly是否DEP兼容
- Dumpbin
	- `dumpbin /headers printCtl4RA.dll`
	- 开启DEP兼容是这样的：

			140 DLL characteristics
                   Dynamic base
                   NX compatible

	- 没开启DEP兼容是这样的：

			40 DLL characteristics
                   Dynamic base

	- 开启DEP兼容的Assembly中，如果出现执行数据段指令的现象，就会造成AV
	
			# Case: 853325217130511

			(fc8.908): Access violation - code c0000005 (first/second chance not available)
			eax=5a0b014c ebx=23e97c70 ecx=1cef6d78 edx=00000080 esi=2f11ada0 edi=23ac8398
			eip=3a726567 esp=1958f9a4 ebp=1958f9b0 iopl=0         nv up ei pl nz na pe nc
			cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206
			3a726567 00ee            add     dh,ch

			0:077> 
			 # ChildEBP RetAddr  
			00 1958f9a0 59c92909 0x3a726567 
			01 1958f9b0 59c94813 VPhone!webrtc::test::UdpSocket2Windows::IOCompleted(struct webrtc::test::PerIoContext * pIOContext = 0x23ac8398, unsigned int ioSize = 0xac, unsigned int error = 0)+0xb9
			02 1958f9d8 59be371c VPhone!webrtc::test::UdpSocket2WorkerWindows::Process(void)+0xd3
			03 1958f9e4 59be396b VPhone!webrtc::ThreadWindows::Run(void)+0x6c
			04 1958f9ec 5a05fae7 VPhone!webrtc::ThreadWindows::StartThread(void * lp_parameter = 0x1d351000)+0xb
			05 1958fa24 5a05fc0f VPhone!_callthreadstartex(void)+0x1b
			06 1958fa30 7625ed5c VPhone!_threadstartex(void * ptd = <Value unavailable error>)+0x7c
			07 1958fa3c 772937eb kernel32!BaseThreadInitThunk+0xe
			08 1958fa7c 772937be ntdll!__RtlUserThreadStart+0x70
			09 1958fa94 00000000 ntdll!_RtlUserThreadStart+0x1b

			0:077> !address 0x3a726567
			Usage:                  Heap
			Base Address:           3a5c0000
			End Address:            3aa33000
			Region Size:            00473000 (   4.449 MB)
			State:                  00001000          MEM_COMMIT
			Protect:                00000004          PAGE_READWRITE
			Type:                   00020000          MEM_PRIVATE
			Allocation Base:        3a5c0000 
			Allocation Protect:     00000004          PAGE_READWRITE -> 这个地址支持读写，不能执行，所以AV
			More info:              heap owning the address: !heap 0x2a0000
			More info:              heap large/virtual block
			More info:              heap entry containing the address: !heap -x 0x3a726567

- Editbin可以直接修改Assembly的DEP
	- 对单个Assembly禁用DEP：`editbin /NXCOMPAT:NO printCtl4RA.dll`
	- 对单个Assembly启用DEP：`editbin /NXCOMPAT printCtl4RA.dll`
	- 比较修改前后的内容，可以用DiffBin：

		![DiffBin](http://7xudfs.com1.z0.glb.clouddn.com/c357331791434ffe98d84126ee441091-DiffBin.png)
 
- 也可以全局改
	- 禁用：`bcdedit.exe /set nx AlwaysOff`，重启机器
	- 启用：`bcdedit.exe /set nx AlwaysOn`，重启机器
- 也可以在编译时指定选项
	- 参考 [MSDN](https://msdn.microsoft.com/en-us/library/ms235442(v=vs.80).aspx)

	![VS_NXCompat.png](http://7xudfs.com1.z0.glb.clouddn.com/c357331791434ffe98d84126ee441091-VS_NXCompat.png)

- 参考：[Technet Blog](http://blogs.technet.com/themes/blogs/generic/postlist.aspx?WeblogApp=srd&y=2009&m=06&d=1&PageIndex=1&PostSortBy=MostRecent&pi14504=1)

### Dump Socket Handler

用`!msafdext.sock <socket_handler>`扩展命令可以Dump出socket对象。

	0:022> kML
	 # ChildEBP RetAddr  
	00 04e8fe0c 7c957d0b ntdll!KiFastSystemCallRet
	01 04e8fe10 71a81af5 ntdll!ZwWaitForSingleObject+0xc
	02 04e8fe4c 71a81a03 mswsock!SockWaitForSingleObject+0x19d
	03 04e8ff3c 71b6283c mswsock!WSPSelect+0x380
	04 04e8ff8c 641c4929 ws2_32!select+0xb9
	......
	07 04e8ffec 00000000 kernel32!BaseThreadStart+0x34
	0:022> .frame 0n2;dv /t /v
	02 04e8fe4c 71a81a03 mswsock!SockWaitForSingleObject+0x19d [d:\nt\net\sockets\winsock2\wsp\mswsock\msafdlib\proc.c @ 1792]
	04e8fe54          void * Handle = 0x0000082c
	04e8fe58          unsigned int SocketHandle = 0x81c
	04e8fe5c          unsigned long BlockingHookUsage = 0
	......
	
	0:022> !msafdext.sock 0x81c
	Handle   DSOCKET  Flags Provider (stack backtrace)
	0000081C 007F89D8 PAO   007F2728-AFD Tcpip [UDP/IP]
	SOCKET_INFORMATION @ 029533a0:
	    State                          = Connected
	    ReferenceCount                 = 1
	    Handle                         = 0000081c
	    AddressFamily                  = 2
	    SocketType                     = 2
	    Protocol                       = 17
	    ......
	    LocalAddress                   = 02953468
	    LocalAddressLength             = 16
	        SOCKADDR @ 02953468
	            sin_family = 2 (IP)
	            sin_port   = 3456
	            sin_addr   = 127.0.0.1
	    RemoteAddress                  = 02953478
	    RemoteAddressLength            = 16
	        SOCKADDR @ 02953478
	            sin_family = 2 (IP)
	            sin_port   = 3456
	            sin_addr   = 127.0.0.1
	    TdiAddressHandle               = 00000820
	    ......

## 常见问题的排查思路（三板斧）

### Crash
- 确定异常类型，Crash大致有三种
	- 真正的Crash（SecondChance异常）：程序抛出未捕捉异常，进程崩溃退出
	- First Chance Exception：异常被捕捉到，进程没有退出
		- 部分应用程序会有自己的Application Log，可以看到Try/Catch逻辑中打出的Log，从而确认有FirstChance异常
		- 另一部分应用程序会借用Windows EventLog，把异常信息输出到Application EventLog中
	- 进程结束，但不是Crash，而是应用程序的代码逻辑自己结束了进程
- 收集Crash Dump
	- 对于SecondChance异常，直接收集Crash Dump
		- DebugDiag
		- Procdump
		- WER
	- 对于FirstChance异常，需要先确定异常类型（如果没有就收集所有的异常类型，收集10个）
		- DebugDiag
		- Procdump
	- 对于进程自行结束的，可以针对Terminate事件收集Dump
		- DebugDiag
		- Procdump
- 分析异常原因
	- .NET异常
		- 在StackObject或者GCHeap中找到异常对象
		- 打印Callstack，结合DSO和Review Code（SaveAllModule & ILSpy）
	- Native异常 
		- 找到异常抛出点
		- Callstack+传入参数+Symbol文件

### Hang
- 收集Hang Dump
	- 在进程Hang的时候，间隔10秒左右，手动敲命令收集，通常收集3个dump
	- 对于偶发性Hang，Hang时不方便手动收集的情况，可以设置DebugDiag或者Procdump规则，自动收集Dump。
- 分析Hang的原因
	- 对比Dump的Callstack，看Pending在哪些线程
	- 看`!lock`或者`!syncblk`，看是否有死锁现象
	- `!analyze -v hang`
- 常见的Hang原因
	- GC
	- 等WebService返回
	- 等DB返回
	- AsyncLock
	- SessionLock
	- 死锁

### High CPU
- 定位什么进程占用了主要的CPU资源
	- 性能计数器（Performance Counter）
	- 任务管理器（TaskManager）也可以，但它只能看当前时刻的情况，不能记录下趋势和时间的Map关系
- 定位什么线程占用了主要的CPU资源
	- 确定了哪一个进程之后，可以在问题发生时，间隔10秒左右，收集3个User Mode Dump
	- 收集Dump后通过`!runaway 3`找到各个线程的CPU占用时间
	- 比对收集时间相邻的Dump，可以找到CPU占用时间较多的线程是哪些
- 看哪些业务逻辑/代码消耗了这些CPU资源
	- 对Dump中（当前）占用CPU最多的线程，Dump Callstack，看问题发生时他们在执行什么代码
	- 将DLL Dump出来，反编译，Review源码
	- Research，看哪些Code Pattern可能造成CPU资源较高
	- Xperf 确认占用时间较多的函数
- 常见的Pattern
	- 频繁GC：GC Time超过15%
	- 正则表达式
	- 字符串处理
	- LINQ
	- 无阻塞的无限循环   

### Memory Leak
- 确定是不是Memory Leak
	- 服务进程业务量下降时，Memory是否会随之下降？
	- Tab或者WinForm窗口关闭时，客户端进程的Memory是否会随之下降？
	- 如果Memory只升不降，那么Memory Leak的可能性较大
- 对Memory Leak，收集Dump，分析Leak类型
	- 在Memory上升阶段，收集若干dump，比如1G/1.5G/2G
	- 如果不方便手动收集，可以编写脚本，用Procdump收集，或者DebugDiag
	- 分析Dump，可以看到内存增加的主要部分是什么
		- GC Heap
		- Dynamic Assembly
		- Native Heap
		- Native Unknown 
- 对Native Memory Leak，Hook Track Leak，收集Dump，分析原因
	- DebugDiag & TrackLeak.dll
	- 自动分析
		- DebugDiag Analysis

## 案例介绍

### Hang Case: 566733417260611
- Symptom
	- Windows service (AService.exe) will call an B.exe in background (session 0)
	- B.exe could work when run manually in cmd window
	- Windows service AService.exe could launch other exe in background without any hang

- Analysis
	- Repro issue, collect hang dump & procmon log
		- Download [procdump](https://technet.microsoft.com/en-us/sysinternals/dd996900.aspx)
		- Download [procmon](https://technet.microsoft.com/en-us/library/bb896645.aspx), Extract to `C:\mstrace` 
		- Open a cmd window as admin, run: 

				cd C:\mstrace 
				procmon /backingfile C:\mstrace\logfile.pml /AcceptEula /Minimized /Quiet 

		- Repro issue
		- Run command in cmd window: `procdump -ma -s 10 -n 3 <PID>`, for example:

				# <PID of AService.exe> = 2312
				procdump -ma -s 10 -n 3 2312

		- Run command to stop procmon: `procmon /terminate`
		- Collect dump & procmon logs, upload to our workspace.
		- Send B.exe to us, too.

	- Analyze Dump
		- Check Locks

				0:015> !locks
				Scanned 21 critical sections

			No locks, so diff callstack between 3 dumps.

		- Check callstack

				0:015> ~*kpnL		
				   0  Id: 11f0.1138 Suspend: 0 Teb: 00007ff5`ff7de000 Unfrozen
				 # Child-SP          RetAddr           Call Site
				......
				06 000000c8`643ae860 00007ffc`e4110501 System_ServiceProcess_ni!System.ServiceProcess.ServiceBase.Run(<HRESULT 0x80004001>)+0x1fe
				07 000000c8`643ae8c0 00007ffd`43763753 AService!AOrg.WinEng.MyApps.Service.AService.Main(<HRESULT 0x80004001>)+0x81
				......
				0c 000000c8`643aeb20 00007ffd`438bf596 clr!RunMain(class MethodDesc * pFD = <Value unavailable error>, int * piRetVal = 0x000000c8`643aed50, class PtrArray ** stringArgs = 0x00000000`00000000)+0x1ba
				0d 000000c8`643aed00 00007ffd`438bf4d4 clr!Assembly::ExecuteMainMethod(class PtrArray ** stringArgs = 0x00000000`00000000)+0xba
				......
				
				   7  Id: 11f0.354 Suspend: 0 Teb: 00007ff5`ff5ea000 Unfrozen
				 # Child-SP          RetAddr           Call Site
				......
				08 000000c8`7ebadb60 00007ffd`41813b23 clr!ThreadNative::Join(class ThreadBaseObject * pThisUNSAFE = 0x000000c8`6542ad68, int Timeout = 0n-1)+0xec
				09 000000c8`7ebadcd0 00007ffd`418173ba System_ni!System.Diagnostics.ShellExecuteHelper.ShellExecuteOnSTAThread(<HRESULT 0x80004001>)+0x93
				......
				0c 000000c8`7ebadda0 00007ffc`e49e4c03 Common!AOrg.WinEng.MyInstaller.Scripts.InstallerContext.LaunchReporter(<HRESULT 0x80004001>)+0x17d
				......
				29 000000c8`7ebaec50 00007ffc`e496ea3d Microsoft_AspNet_SignalR_Client!Microsoft.AspNet.SignalR.Client.HubConnection.OnMessageReceived(<HRESULT 0x80004001>)+0x2a3
				......
				2b 000000c8`7ebaed80 00007ffd`42622490 mscorlib_ni!System.Threading.Tasks.Task.Execute(<HRESULT 0x80004001>)+0x47
				......
				
				  15  Id: 11f0.ec8 Suspend: 0 Teb: 00007ff5`ff5f8000 Unfrozen
				 # Child-SP          RetAddr           Call Site
				......				
				01 000000c8`00fdc0b0 00007ffd`4cd58ae2 user32!DialogBox2(struct HWND__ * hwnd = 0x00000000`0005008c, struct HWND__ * hwndOwner = 0x00000000`00000000, int fDisabled = <Value unavailable error>, int fOwnerIsActiveWindow = <Value unavailable error>)+0x212
				......
				07 000000c8`00fdc2c0 00007ffd`4b038526 shdocvw!SafeOpenPromptForShellExec(struct HWND__ * hwnd = <Value unavailable error>, wchar_t * pszFile = 0x000000c8`7e336498 "\\ShareFolder\apps\AOrg\WinEng\SoftwareDelivery\MyAppsReporting\B.exe\1.0\B.exe")+0x6c2
				08 000000c8`00fde790 00007ffd`4ac44450 shell32!CInvokeCreateProcessVerb::_ZoneCheckFile+0x3f40b6
				09 000000c8`00fde800 00007ffd`4ac44339 shell32!CInvokeCreateProcessVerb::_VerifyZoneTrust(wchar_t * pszFile = 0x000000c8`7e336498 "\\ShareFolder\apps\AOrg\WinEng\SoftwareDelivery\MyAppsReporting\B\1.0\B.exe")+0x24
				0a 000000c8`00fde830 00007ffd`4ac426a0 shell32!CInvokeCreateProcessVerb::_VerifyExecTrust(void)+0xc5
				0b 000000c8`00fde880 00007ffd`4ac450c3 shell32!CInvokeCreateProcessVerb::Execute(void)+0x30
				......
				24 000000c8`00fdf490 00007ffd`43783e1e clr!ThreadNative::KickOffThread(void * pass = 0x000000c8`00331b30)+0x16f
				......

	- In thread 15, we could find:
		- the launched exe is: `\\ShareFolder\apps\AOrg\WinEng\SoftwareDelivery\MyAppsReporting\B\1.0\B.exe`
		- there was a DialogBox popup, which is not correct, since DialogBox in background will hang the service process.

				0:015> kL10
				 # Child-SP          RetAddr           Call Site
				00 000000c8`00fdc0a8 00007ffd`4cd554fb user32!ZwUserWaitMessage+0xa
				01 000000c8`00fdc0b0 00007ffd`4cd58ae2 user32!DialogBox2+0x212
				......
				07 000000c8`00fdc2c0 00007ffd`4b038526 shdocvw!SafeOpenPromptForShellExec+0x6c2
				08 000000c8`00fde790 00007ffd`4ac44450 shell32!CInvokeCreateProcessVerb::_ZoneCheckFile+0x3f40b6
				09 000000c8`00fde800 00007ffd`4ac44339 shell32!CInvokeCreateProcessVerb::_VerifyZoneTrust+0x24
				0a 000000c8`00fde830 00007ffd`4ac426a0 shell32!CInvokeCreateProcessVerb::_VerifyExecTrust+0xc5
				0b 000000c8`00fde880 00007ffd`4ac450c3 shell32!CInvokeCreateProcessVerb::Execute+0x30
				......
				0f 000000c8`00fdea10 00007ffd`4ac408e5 shell32!CShellExecute::_ExecuteAssoc+0x11a
				
				0:015> dx Debugger.Sessions[0].Processes[4592].Threads[3784].Stack.Frames[1].SwitchTo();dv /t /v
				Debugger.Sessions[0].Processes[4592].Threads[3784].Stack.Frames[1].SwitchTo()
				@rdi              struct HWND__ * hwnd = 0x00000000`0005008c
				@rbx              struct HWND__ * hwndOwner = 0x00000000`00000000
				......
				000000c8`00fdc0e0 struct tagMSG msg = {msg=0x1e00d6 wp=0x3043394a4aee lp=0x5000}
				<unavailable>     struct HWND__ * hwndCapture = <value unavailable>
				@rbp              struct tagWND * pwnd = 0x000000c8`645be0b0
				
				0:015> !userexts.dw -v hwnd 0x00000000`0005008c 
				pwnd    = 0x000000c8645be0b0
					handle             0x000000000005008c
					......
					spwndChild         0xfffff90141c09280     "We can¡¯t verify who created this file. Are you sure you want to run this file?"
					......
					pName              "Open File - Security Warning"
					......
	
		- So, thread 15 hang due to B.exe came from net share
	- Check thread 7, it wait for thread join()
		- Callstack

				7  Id: 11f0.354 Suspend: 0 Teb: 00007ff5`ff5ea000 Unfrozen
				 # Child-SP          RetAddr           Call Site
				00 000000c8`7ebad568 00007ffd`4a9013ed ntdll!ZwWaitForMultipleObjects(void)+0xa
				01 000000c8`7ebad570 00007ffd`438392aa KERNELBASE!WaitForMultipleObjectsEx(unsigned long nCount = 1, void ** lpHandles = <Value unavailable error>, int bWaitAll = 0n0, unsigned long dwMilliseconds = 0, int bAlertable = 0n1)+0xe1
				02 000000c8`7ebad850 00007ffd`438391bf clr!WaitForMultipleObjectsEx_SO_TOLERANT(unsigned long nCount = 1, void ** lpHandles = 0x000000c8`7ebadae8, int bWaitAll = 0n0, unsigned long dwMilliseconds = 0xffffffff, int bAlertable = 0n1)+0x62
				03 (Inline Function) --------`-------- clr!Thread::DoAppropriateAptStateWait+0x44
				04 000000c8`7ebad8b0 00007ffd`43838fb1 clr!Thread::DoAppropriateWaitWorker(int countHandles = 0n1, void ** handles = 0x000000c8`7ebadae8, int waitAll = 0n0, unsigned long millis = 0xffffffff, WaitMode mode = WaitMode_Alertable (0n1))+0x243
				05 000000c8`7ebad9b0 00007ffd`43ae5b6b clr!Thread::DoAppropriateWait(int countHandles = 0n1, void ** handles = 0x000000c8`7dadbd88, int waitAll = 0n1136730664, unsigned long millis = 0xffffffff, WaitMode mode = WaitMode_Alertable (0n1), struct PendingSync * syncState = 0x00000000`00000000)+0x7d
				06 000000c8`7ebada30 00007ffd`43c0f06a clr!Thread::JoinEx(unsigned long timeout = 0xffffffff, WaitMode mode = WaitMode_Alertable (0n1))+0xeb
				07 000000c8`7ebadad0 00007ffd`43c10998 clr!ThreadNative::DoJoin(class ThreadBaseObject * DyingThread = <Value unavailable error>, int timeout = <Value unavailable error>)+0xfe
				08 000000c8`7ebadb60 00007ffd`41813b23 clr!ThreadNative::Join(class ThreadBaseObject * pThisUNSAFE = 0x000000c8`6542ad68, int Timeout = 0n-1)+0xec
				09 000000c8`7ebadcd0 00007ffd`418173ba System_ni!System.Diagnostics.ShellExecuteHelper.ShellExecuteOnSTAThread(<HRESULT 0x80004001>)+0x93
				0a 000000c8`7ebadd10 00007ffd`41844e9c System_ni!System.Diagnostics.Process.StartWithShellExecuteEx(<HRESULT 0x80004001>)+0x23a
				0b 000000c8`7ebadd60 00007ffc`e49f071d System_ni!System.Diagnostics.Process.Start(<HRESULT 0x80004001>)+0x3c
				0c 000000c8`7ebadda0 00007ffc`e49e4c03 Common!AOrg.WinEng.MyInstaller.Scripts.InstallerContext.LaunchReporter(<HRESULT 0x80004001>)+0x17d
				0d 000000c8`7ebade30 00007ffc`e49e44e3 Common!AOrg.WinEng.MyInstaller.Scripts.InstallerContext+<Execute>d__78.MoveNext(<HRESULT 0x80004001>)+0x1183
				0e 000000c8`7ebade80 00007ffd`42622490 Common!AOrg.WinEng.MyInstaller.Scripts.InstallerContext+<Execute>d__78.MoveNext(<HRESULT 0x80004001>)+0xa63
				0f 000000c8`7ebae1b0 00007ffd`42622327 mscorlib_ni!System.Threading.ExecutionContext.RunInternal(<HRESULT 0x80004001>)+0x160

				0:007> lmvm Common
				Browse full module list
				start             end                 module name
				000000c8`7d4d0000 000000c8`7d504000   Common   C (no symbols)           
				    Loaded symbol image file: Common.dll
				    ......

		- Dump Common.dll & reflect: `!mex.writemodule -a -p D:\dumpModules`

				// Aorg.WinEng.MyInstaller.Scripts.InstallerContext
				private static void LaunchReporter()
				{
					ProcessStartInfo processStartInfo = new ProcessStartInfo
					{
						FileName = Variables.BPath,
						Arguments = "/svc-env PROD",
						UseShellExecute = true,
						CreateNoWindow = true,
						WindowStyle = ProcessWindowStyle.Hidden
					};
					bool flag = !File.Exists(processStartInfo.FileName);
					if (flag)
					{
						Log.Debug(string.Format("Error to load B {0}", processStartInfo.FileName));
						throw new Exception("B can't find!");
					}
					Process.Start(processStartInfo);
				}

		- Reflect ShellExecuteHelper， start thread then join

				// System.Diagnostics.ShellExecuteHelper
				public bool ShellExecuteOnSTAThread()
				{
					if (Thread.CurrentThread.GetApartmentState() != ApartmentState.STA)
					{
						Thread expr_1D = new Thread(new ThreadStart(this.ShellExecuteFunction));
						expr_1D.SetApartmentState(ApartmentState.STA);
						expr_1D.Start();
						expr_1D.Join();
					}
					else
					{
						this.ShellExecuteFunction();
					}
					return this._succeeded;
				}

- Conclusion
	- DialogBox popup due to B.exe not trust (in share folder)
	- DialogBox hang AService.exe
	- Research, [MSDN Blog](https://blogs.msdn.microsoft.com/askie/2009/06/19/how-to-bypass-the-security-warning-unknown-publisher-with-the-checkbox-always-ask-before-opening-this-file/)，The behavior of “popup warning message box for unknown publisher exe in UNC share folder” is by design.
 
- Solution
	- We could try move B.exe to local machine
	- Or, we could signature B.exe, refer to [MSDN Blog](https://blogs.msdn.microsoft.com/ieinternals/2011/03/22/everything-you-need-to-know-about-authenticode-code-signing/)
	- Or, we could diable security check, refer to [Technet](https://technet.microsoft.com/en-us/library/bb496428.aspx?f=255&MSPPError=-2147217396), or [blog](http://www.technipages.com/fix-we-cant-verify-who-created-this-file-error)
	- In this case，adding to TrustSite won't fix, adding to LocalIntranet works

		![Add-UNC-To-LocalIntranet.png](http://7xudfs.com1.z0.glb.clouddn.com/c357331791434ffe98d84126ee441091-Add-UNC-To-LocalIntranet.png)

### Native Memory Leak Case: 953422410350611
- Symptom
	- XP
	- 应用程序报错：OutOfMemory。图像无法显示，gdi+绘制图像时界面是大红叉，操作系统提示虚拟内存不足，只能退出应用程序才能恢复正常。

		![Low-Virtual-Memory.jpg](http://7xudfs.com1.z0.glb.clouddn.com/c357331791434ffe98d84126ee441091-Low-Virtual-Memory.jpg)

	- EventLog

			System.Drawing
			StackTrace:
			   at System.Drawing.Graphics.CheckErrorStatus(Int32 status)
			   at System.Drawing.Graphics.DrawImage(Image image, PointF[] destPoints)
			   at BOC.WinFormUI.ImageViewer.OnPaint(PaintEventArgs e)
			   at System.Windows.Forms.Control.PaintWithErrorHandling(PaintEventArgs e, Int16 layer, Boolean disposeEventArgs)
			   at System.Windows.Forms.Control.WmPaint(Message& m)
			   at System.Windows.Forms.Control.WndProc(Message& m)
			   at System.Windows.Forms.ScrollableControl.WndProc(Message& m)
			   at System.Windows.Forms.Control.ControlNativeWindow.OnMessage(Message& m)
			   at System.Windows.Forms.Control.ControlNativeWindow.WndProc(Message& m)
			   at System.Windows.Forms.NativeWindow.Callback(IntPtr hWnd, Int32 msg, IntPtr wparam, IntPtr lparam)
			Message:
			Out of memory.
			 
			System.Drawing
			StackTrace:
			   at System.Drawing.Image.FromFile(String filename, Boolean useEmbeddedColorManagement)
			   at System.Drawing.Image.FromFile(String filename)
			   at BOC.FrontEnd.Client.Framework.Utility.ImageItem.get_Item(String name)
			   at BOC.WinFormUI.RemoteSupervisorOverrideResponse_new.DownLoadPictures()
			   at BOC.WinFormUI.RemoteSupervisorOverrideResponse_new._BackgroundWorker_DoWork(Object sender, DoWorkEventArgs e)
			Message:
			Out of memory.

- Analysis
	- EPS Support Engineer建议调整虚拟内存
		- 可以看一下虚拟内存的设置，对于虚拟内存的大小，如果是X86系统，建议和物理内存一样大，如果是X64系统，建议大小是物理内存的1.5倍。
		- 以下是设置pagefile 的步骤：
			- 右击“我的电脑”，选择“属性”。
			- 设置pagefile。
			- 选择高级系统设置，选择“高级”。在性能中选择“设置”。选择“高级”，选择更改。
			
				![Set-PageFile.jpg](http://7xudfs.com1.z0.glb.clouddn.com/c357331791434ffe98d84126ee441091-Set-PageFile.jpg)

	- 鉴于WorkAround方法是重启进程，所以先收集进程Dump，发现有1.8G（如果是32bit进程，进程空间只有2G，此时就肯定有问题了。64bit的需要和开发同事确认），在这个case中，这里是32bit进程，所以可以确认1.8G是不合逻辑的。所以我们从进程Dump开始查起。
	- `!eeheap -gc`： .NET的Heap只有90M左右

			Number of GC Heaps: 1
			generation 0 starts at 0x3f8b0444
			generation 1 starts at 0x3f8a77d4
			generation 2 starts at 0x012d1000
			ephemeral segment allocation context: none
			segment    begin allocated     size
			012d0000 012d1000  022ce648 0x00ffd648(16766536)
			09390000 09391000  0a387acc 0x00ff6acc(16739020)
			19e80000 19e81000  1ae7b5ac 0x00ffa5ac(16754092)
			3f0d0000 3f0d1000  3f8b4450 0x007e3450(8270928)
			Large object heap starts at 0x022d1000
			segment    begin allocated     size
			022d0000 022d1000  032b9010 0x00fe8010(16678928)
			1ae80000 1ae81000  1bcf8630 0x00e77630(15169072)
			45510000 45511000  457b8dc0 0x002a7dc0(2784704)
			Total Size  0x58d8f10(93163280)
			------------------------------
			GC Heap Size  0x58d8f10(93163280)

	- !address -summary
		- 对XP，需要用低版本的Windbg，6.11版本

				0:000> !address -summary
				-------------------- Usage SUMMARY --------------------------
				    TotSize (      KB)   Pct(Tots) Pct(Busy)   Usage
				   6aa49000 ( 1747236) : 83.32%    98.25%    : RegionUsageIsVAD
				   13739000 (  318692) : 15.20%    00.00%    : RegionUsageFree
				     6b1000 (    6852) : 00.33%    00.39%    : RegionUsageImage
				      52000 (     328) : 00.02%    00.02%    : RegionUsageStack
				      16000 (      88) : 00.00%    00.00%    : RegionUsageTeb
				    1743000 (   23820) : 01.14%    01.34%    : RegionUsageHeap
				          0 (       0) : 00.00%    00.00%    : RegionUsagePageHeap
				       1000 (       4) : 00.00%    00.00%    : RegionUsagePeb
				       1000 (       4) : 00.00%    00.00%    : RegionUsageProcessParametrs
				       1000 (       4) : 00.00%    00.00%    : RegionUsageEnvironmentBlock
				       Tot: 7ffe1000 (2097028 KB) Busy: 6c8a8000 (1778336 KB)
				 
				-------------------- Type SUMMARY --------------------------
				    TotSize (      KB)   Pct(Tots)  Usage
				   13739000 (  318692) : 15.20%   : <free>
				          0 (       0) : 00.00%   : MEM_IMAGE
				          0 (       0) : 00.00%   : MEM_MAPPED
				   6c8a8000 ( 1778336) : 84.80%   : MEM_PRIVATE
				 
				-------------------- State SUMMARY --------------------------
				    TotSize (      KB)   Pct(Tots)  Usage
				   6c8a8000 ( 1778336) : 84.80%   : MEM_COMMIT
				   13739000 (  318692) : 15.20%   : MEM_FREE
				          0 (       0) : 00.00%   : MEM_RESERVE
				 
				Largest free region: Base 781cb000 - Size 00e35000 (14548 KB)

		- 可以看到Private/Commit占用了最多内存，另外就是RegionUsageIsVAD，这个不归Heap管，参考[understand-process-address-space-usage](https://codesequoia.wordpress.com/2008/11/28/understand-process-address-space-usage/)
			- IsVAD: The page has been allocated by VirtualAlloc() or other memory allocation function except heap management functions.
			- Image: The page is used to store the executable or DLLs.
			- Stack: The page is used for stack.
			- Heap: The page has been allocated by heap management functions.

	- 进一步分析
		- 进程的内存空间是32bit的，确实快用完了，MEM_Private用了1.7G，其中98.25是RegionUsageIsVAD（Non-Heap）
		- GC Heap Size  0x6210710(102,827,792)，Image用了149,144,064，Heap用了78,237,696，都不多
		- `address -f:Unk`占了1.76G(1895484928)，共3195个Block，其中大小为0x240000和0x900000的Block有230个，共1.07G，占了主要部分

				>>> aList = [int(line.split()[2],16) for line in open("a.txt") if line.strip() and int(line.split()[2],16)>(2*1024*1024)]
				>>> from collections import Counter
				>>> Counter(aList)
				Counter({2359296: 144, 9437184: 86, 3932160: 19, 5763072: 13, 3145728: 4, 16777216: 2, 2322432: 2, 2781184: 1, 33464320: 1, 8622080: 1, 4931584: 1, 4190208: 1, 3538944: 1, 3657728: 1, 7995392: 1, 2609152: 1, 11988992: 1, 8257536: 1, 12582912: 1, 2293760: 1, 2887680: 1, 4988928: 1, 2764800: 1, 3174400: 1, 14897152: 1, 6438912: 1, 2895872: 1, 2662400: 1, 3563520: 1, 9302016: 1, 4669440: 1, 10514432: 1, 30408704: 1, 8294400: 1, 3473408: 1, 4497408: 1, 15118336: 1, 2801664: 1, 2539520: 1, 6483968: 1, 4521984: 1, 4313088: 1, 4653056: 1, 7467008: 1, 14237696: 1, 2101248: 1, 16560128: 1, 6377472: 1, 2883584: 1, 2842624: 1, 8482816: 1, 2990080: 1})
				>>> aList = [line.split()[2] for line in open("a.txt") if line.strip() and int(line.split()[2],16)>(2*1024*1024)]
				>>> Counter(aList)
				Counter({'240000': 144, '900000': 86, '3c0000': 19, '57f000': 13, '300000': 4, '1000000': 2, '237000': 2, '8df000': 1, '474000': 1, '1fea000': 1, '2a3000': 1, 'e6b000': 1, '37d000': 1, '4b4000': 1, '817000': 1, '839000': 1, '230000': 1, '360000': 1, 'fcb000': 1, '26c000': 1, '27d000': 1, 'e35000': 1, 'c00000': 1, '2c3000': 1, '44a000': 1, 'b6f000': 1, '624000': 1, '470000': 1, '615000': 1, 'd94000': 1, '62f000': 1, '1d00000': 1, '4c2000': 1, '7e0000': 1, '41d000': 1, 'a07000': 1, '3ff000': 1, '2a7000': 1, '307000': 1, '7e9000': 1, '2da000': 1, '28a000': 1, '2c0000': 1, '7a0000': 1, '201000': 1, '71f000': 1, '350000': 1, '2c1000': 1, '366000': 1, '2ac000': 1, '2b6000': 1, '450000': 1})
				>>> aList = [line.split()[2] for line in open("a.txt") if line.strip() and int(line.split()[2],16)>(2*1024*1024)]
				>>> cList = [i for i in aList if i in ['240000', '900000']]
				>>> cList = [int(i,16) for i in aList if i in ['240000', '900000']]
				>>> len(cList)
				230
				>>> sum(cList)
				1151336448
				>>> sum(cList)/1024.0/1024.0/1024.0
				1.072265625

		- 尝试分析0x240000和900000这两个类型的block，发现这些空间内存储的数据看起来像图片（这些凌乱而又部分连续的数据，如果不是图片，我想不出来还有什么可能）。首先肯定不是ASCII或者Unicode，一定是Binary，但如果是一般的Binary又不应该这么有规律（部分连续）。这样看来，可能是部分和显示图片有关的内存用完没有释放（`!address -F:Unk`，`!heap -stat`，`!mex.strings`）

				3143f5f8 ~~~~~~
				3143f613 ~~~}}}||||||}}}~~~

		- 这里不存在GDI Objects泄漏（几个Dump中并没有增加趋势），需要`!load gdikdx`，[参考](http://www.osronline.com/article.cfm?id=173)

				0:000> !dml_proc
				DbgId  PID    Image file name
				0      68c    ...\BLClientCN\Release\Assembly\ClientApplication.exe
				 
				0:000> !gdikdx.dumpobj -p 68c DEF
				......
				63e, 4a0a063e,      0, Unread,  68c, e41da908,    LFONT,   4a0a,      0, 0c0f3cc8, 0c0f3cc8
				Total objects = 123

		- 结论：
			- 主要的内存消耗在于Native-NonHeap
			- 如果要继续分析是哪个DLL申请了这些内存，需要Hook Leak Track DLL到进程中，然后在内存增长时收集3个Dump（1G，1.3G，1.6G）

	- DebugDiag/LeakTrack
		- XP要用[DebugDiag1.2](https://www.microsoft.com/en-us/download/details.aspx?id=26798)
		- API：GdiPlus!GpMemoryBitmap::AllocBitmapDatas吃掉了主要内存

				ClientApplication.exe__PID__852__Date__06_06_2016__Time_03_46_00PM__876
				GdiPlus!GpMemoryBitmap::AllocBitmapData+74: 592.02 MBytes worth of outstanding allocations.
				ClientApplication.exe__PID__852__Date__06_06_2016__Time_04_05_00PM__866
				GdiPlus!GpMemoryBitmap::AllocBitmapData+74: 800.48 MBytes worth of outstanding allocations.
				ClientApplication.exe__PID__852__Date__06_06_2016__Time_04_11_05PM__863__Leak Dump
				GdiPlus!GpMemoryBitmap::AllocBitmapData+74: 1.02 GBytes worth of outstanding allocations.
				ClientApplication.exe__PID__852__Date__06_06_2016__Time_04_21_31PM__571
				GdiPlus!GpMemoryBitmap::AllocBitmapData+74: 1.26 GBytes worth of outstanding allocations.

	- Review Code
		- a.	BOC.FrontEnd.Client.Framework.Utility.ImageBuffer中的BOC.FrontEnd.Client.Framework.Utility.ImageItem对象持续增加，28 / 37 / 46 /58

				0:000> !do 09d225c4 
				Name: System.Collections.Generic.Dictionary`2[[System.String, mscorlib],[BOC.FrontEnd.Client.Framework.Utility.ImageItem, Framework]]
				MethodTable: 055b3a90
				EEClass: 790ead0c
				Size: 52(0x34) bytes
				GC Generation: 2
				(C:\WINDOWS\assembly\GAC_32\mscorlib\2.0.0.0__b77a5c561934e089\mscorlib.dll)
				Fields:
				      MT    Field   Offset                 Type VT     Attr    Value Name
				79332e08  40009af        4       System.Int32[]  0 instance 1a946b28 buckets
				00000000  40009b0        8              SZARRAY  0 instance 1a946bc8 entries
				79332eb8  40009b1       20         System.Int32  1 instance       28 count
				...

		- 继续检查，发现每个BOC.FrontEnd.Client.Framework.Utility.ImageItem对象中最多可以缓存100个Item

				0:000> !do 09d2e414 
				Name: BOC.FrontEnd.Client.Framework.Utility.ImageItem
				MethodTable: 0b0fd6e4
				EEClass: 0b12baf8
				Size: 44(0x2c) bytes
				(C:\BLClientCN\release\assembly\Framework.dll)
				Fields:
				      MT    Field   Offset                 Type VT     Attr    Value Name
				00000000  400028a        4                       0 instance 09d2e440 dictFiles
				79332eb8  400028b       1c         System.Int32  1 instance      100 _MaxLength
				...

		- 在ImageItem.AddImage()方法中，在执行SaveAsJPEG()方法时和执行之后，BitImage对象和Image对象都没有Dispose ，这会导致GdiPlus!GpMemoryBitmap::AllocBitmapData申请的对象不被释放。

				// BOC.FrontEnd.Client.Framework.Utility.ImageItem
				public void AddImage(string fileName, byte[] imgData)
				{
				    MemoryStream memoryStream = new MemoryStream(imgData);
				    Image img = Image.FromStream(memoryStream);
				    this.AddImage(fileName, img);
				    memoryStream.Close();
				}
				
				// BOC.FrontEnd.Client.Framework.Utility.ImageItem
				public void AddImage(string fileName, Image img)
				{
				    ...
				    string text = string.Format("{0}\\{1}.jpg", this.path, Guid.NewGuid().ToString().ToUpper());
				    ImageItem.SaveAsJPEG(img, text, 45L);
				    if (this.currentSize == this._MaxLength)
				    {
				        string fileName2 = this.names[0];
				        this.RemoveImage(fileName2);
				    }
				    this.dictFiles.Add(fileName, text);
				    this.names.Add(fileName);
				    this.currentSize++;
				}
				
				// BOC.FrontEnd.Client.Framework.Utility.ImageItem
				private static void SaveAsJPEG(Image img, string file, long quality)
				{
				    ImageCodecInfo codec = ImageItem.GetCodec("image/jpeg");
				    EncoderParameters encoderParameters = new EncoderParameters(1);
				    encoderParameters.Param[0] = new EncoderParameter(Encoder.Quality, quality);
				    Bitmap bitmap = new Bitmap(img);
				    bitmap.Save(file, codec, encoderParameters);
				    encoderParameters.Dispose();
				}

- Solution
	- 修改代码，避免内存泄漏

### Native Memory Leak Case: 733654415270611
- Symptom
	- A customer windows services process's private working set memory would raise to high, this issue only found in one Windows Server 2008 SP2 machine, not repro in other 2008 SP2 machines.
	- The logic in this windows services is call OpenProcess to monitor other process, per second.
- Analysis
	- Collect Dumps, Find this is a Native Memory Leak issue
		- First Dump collections, no clr/mscorwks in Memory

				# pwd-exe.dump\PWD.exe_160726_091327.dmp				
				0:000> !mex.grep clr lm
				0:000> !mex.grep msc lm
				75d00000 75dc8000   msctf      (deferred)             
				0:000> !psscor2.eeheap -gc
				Failed to find runtime DLL (mscorwks.dll), 0x80004005
				Extension commands need mscorwks.dll in order to have something to do.

		- The growth memory was mainly in Unknown address

				0:000> ||
				pwd-exe.dump\PWD.exe_160726_091327.dmp
				0:000> !address -summary
				--- Usage Summary ---------------- RgnCount ----------- Total Size -------- %ofBusy %ofTotal
				Free                                     49          780fa000 (   1.876 GB)           93.80%
				<unknown>                               317           29c6000 (  41.773 MB)  32.90%    2.04%
				PageHeap                               6821           2260000 (  34.375 MB)  27.08%    1.68%
				Image                                   154           1814000 (  24.078 MB)  18.96%    1.18%
				Other                                    11           1137000 (  17.215 MB)  13.56%    0.84%
				Heap                                     25            580000 (   5.500 MB)   4.33%    0.27%
				Stack                                    12            400000 (   4.000 MB)   3.15%    0.20%
				TEB                                       4              4000 (  16.000 kB)   0.01%    0.00%
				PEB                                       1              1000 (   4.000 kB)   0.00%    0.00%

				--- Type Summary (for busy) ------ RgnCount ----------- Total Size -------- %ofBusy %ofTotal
				MEM_PRIVATE                            7169           5047000 (  80.277 MB)  63.23%    3.92%
				MEM_IMAGE                               154           1814000 (  24.078 MB)  18.96%    1.18%
				MEM_MAPPED                               22           169b000 (  22.605 MB)  17.81%    1.10%
				
				--- State Summary ---------------- RgnCount ----------- Total Size -------- %ofBusy %ofTotal
				MEM_FREE                                 49          780fa000 (   1.876 GB)           93.80%
				MEM_COMMIT                             3850           4047000 (  64.277 MB)  50.63%    3.14%
				MEM_RESERVE                            3495           3eaf000 (  62.684 MB)  49.37%    3.06%
				
				--- Protect Summary (for commit) - RgnCount ----------- Total Size -------- %ofBusy %ofTotal
				PAGE_READWRITE                         3706           1fc5000 (  31.770 MB)  25.02%    1.55%
				PAGE_READONLY                            88           12cd000 (  18.801 MB)  14.81%    0.92%
				PAGE_EXECUTE_READ                        31            d65000 (  13.395 MB)  10.55%    0.65%
				PAGE_WRITECOPY                           21             4c000 ( 304.000 kB)   0.23%    0.01%
				PAGE_READWRITE|PAGE_GUARD                 4              4000 (  16.000 kB)   0.01%    0.00%
				
				--- Largest Region by Usage ----------- Base Address -------- Region Size ----------
				Free                                         66d0000          65570000 (   1.583 GB)
				<unknown>                                    30a5000            bfb000 (  11.980 MB)
				PageHeap                                     2030000            129000 (   1.160 MB)
				Image                                       763fb000            786000 (   7.523 MB)
				Other                                         429000            fe6000 (  15.898 MB)
				Heap                                         2dec000             d4000 ( 848.000 kB)
				Stack                                        5670000             fd000 (1012.000 kB)
				TEB                                         7ffdb000              1000 (   4.000 kB)
				PEB                                         7ffd9000              1000 (   4.000 kB)
 

			After 50s

				07/26/2016  09:13 AM        68,996,126 PWD.exe_160726_091327.dmp
				07/26/2016  09:14 AM        75,899,118 PWD.exe_160726_091417.dmp

			Dump size add 7M, almost the same with the growth of Unknown memory (Private)

				0:000> ||
				pwd-exe.dump\PWD.exe_160726_091417.dmp
				0:000> !address -summary
				
				--- Usage Summary ---------------- RgnCount ----------- Total Size -------- %ofBusy %ofTotal
				Free                                     47          77979000 (   1.869 GB)           93.43%
				<unknown>                               434           3046000 (  48.273 MB)  35.90%    2.36%
				PageHeap                               6837           2260000 (  34.375 MB)  25.56%    1.68%
				Image                                   150           1814000 (  24.078 MB)  17.91%    1.18%
				Other                                    11           1137000 (  17.215 MB)  12.80%    0.84%
				Heap                                     25            580000 (   5.500 MB)   4.09%    0.27%
				Stack                                    15            500000 (   5.000 MB)   3.72%    0.24%
				TEB                                       5              5000 (  20.000 kB)   0.01%    0.00%
				PEB                                       1              1000 (   4.000 kB)   0.00%    0.00%
				
				--- Type Summary (for busy) ------ RgnCount ----------- Total Size -------- %ofBusy %ofTotal
				MEM_PRIVATE                            7306           57c8000 (  87.781 MB)  65.28%    4.29%
				MEM_IMAGE                               150           1814000 (  24.078 MB)  17.91%    1.18%
				MEM_MAPPED                               22           169b000 (  22.605 MB)  16.81%    1.10%
				
				--- State Summary ---------------- RgnCount ----------- Total Size -------- %ofBusy %ofTotal
				MEM_FREE                                 47          77979000 (   1.869 GB)           93.43%
				MEM_COMMIT                             3968           46db000 (  70.855 MB)  52.69%    3.46%
				MEM_RESERVE                            3510           3f9c000 (  63.609 MB)  47.31%    3.11%
				
				--- Protect Summary (for commit) - RgnCount ----------- Total Size -------- %ofBusy %ofTotal
				PAGE_READWRITE                         3827           265e000 (  38.367 MB)  28.53%    1.87%
				PAGE_READONLY                            88           12cd000 (  18.801 MB)  13.98%    0.92%
				PAGE_EXECUTE_READ                        31            d65000 (  13.395 MB)   9.96%    0.65%
				PAGE_WRITECOPY                           17             46000 ( 280.000 kB)   0.20%    0.01%
				PAGE_READWRITE|PAGE_GUARD                 5              5000 (  20.000 kB)   0.01%    0.00%
				
				--- Largest Region by Usage ----------- Base Address -------- Region Size ----------
				Free                                         6de0000          64e60000 (   1.577 GB)
				<unknown>                                    30a5000            bfb000 (  11.980 MB)
				PageHeap                                     2030000            129000 (   1.160 MB)
				Image                                       763fb000            786000 (   7.523 MB)
				Other                                         429000            fe6000 (  15.898 MB)
				Heap                                         2dec000             d4000 ( 848.000 kB)
				Stack                                        5670000             fd000 (1012.000 kB)
				TEB                                         7ffdb000              1000 (   4.000 kB)
				PEB                                         7ffd9000              1000 (   4.000 kB)

		- GC heap not large, so it should be a Native Memory Leak issue
		- The growth memory was mainly in Unknown address
		- Dump Memory, it seems they are Warning message about OpenProcess call
	- Hook LeakTrack.dll in, then collect dump, couldn't find which API cost this memory
	- Collect TTT & Dump, find the memory was accessed by Application Verification. 
	- Uninstall Application Verification, this issue not repro, Re-install, still not repro
- Solution
	- Uninstall Application Verification

### Crash