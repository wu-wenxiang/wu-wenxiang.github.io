---
layout:         post
title:          用户态程序排错教程-Windbg
category:       course
description:    本文介绍：Windbg的基本功能，常用的插件和命令，以及Windbg在实际案例中的应用。
---

## QuickStart

### 简介

Windbg是Windows平台上的Debug Tool，Unix/Linux世界中功能类似的产品是GDB。WinDbg作为免费的Debugging Tools for Windows包的组成部分被发行（Windbg还有一个Internal Usage的版本，功能更为强大）。WinDbg是有GUI界面的，但它与命令行调试器前端如KD，CDB，NTSD共享了一个调试器后端。

Windbg的功能包括：

- Windbg分为开放版本和内部版本。
- 可用于调试用户态下的应用程序、以及核心态下的驱动程序和操作系统自身。
- 可用于在线的Live Debug或者离线Debug（Memory Dump / TTTracing）
- WinDbg能从服务器自动装载匹配的调试符号文件，如PDB文件。调试符号文件在源代码文件与二进制可执行程序之间创建对应关系。Microsoft的公开的（PDB文件也有Private版本，Private Symbol提供了更详细的信息）符号服务器提供了Windows 2000以后各版本操作系统及服务包的绝大部分符号。

### Install & Config

- Install
	- Public Download [Get Debugging Tools for Windows (WinDbg) (from the SDK)](https://go.microsoft.com/fwlink/p/?LinkId=536682)
	- [Internal Version](http://sharepoint/sites/debug/Tips/Windows%20Debugger.aspx)，或者这个链接：http://debug。别费力气了，非微软员工账号或者在外网都访问不了的。`\\dbg\privates\latest\`，可以直接到这里下载。
	- `dbg_x86.msi`和`dbg_amd64.msi`都装上，分别用于Debug 32bit和64bit进程。安装路径分别是：`C:\Debugger`和`C:\Debugger64`
	- 自动化Dump分析工具也推荐安装：
		- [Matlas](http://toolbox/MAtlas)，MS Internal Usage
		- [DebugDiag2.2](https://www.microsoft.com/en-us/download/details.aspx?id=49924), for Vista+
		- [DebugDiag1.2](https://www.microsoft.com/en-us/download/details.aspx?id=26798), for XP or 2003
- Config
	- Setup symbol path and extension path for WinDBG

		We will add the following environment variables to system to system variables, then you don't need to set them for each debugging session.
     
		![environmenVariable.png](http://7xudfs.com1.z0.glb.clouddn.com/c357331791434ffe98d84126ee441091-environmenVariable.png)
		
		这里设置了两个环境变量：`_NT_SYMBOL_PATH`和`_NT_DEBUGGER_EXTENSION_PATH`。其实`_NT_DEBUGGER_EXTENSION_PATH`不建议设置，因为extension 64bit/32bit不兼容的。推荐将64bit的extenstion直接添加到Windbg 64bit安装目录的winext目录中，将32bit的extenstion直接添加到Windbg 32bit安装目录的winext目录中.

	- Symbol Path
		- Internal的Symbol Path是：
				
				cache*c:\symbols;srv*http://symweb;SRV*\\gcrcssfs\Products\Symbols
				# 或者
				SRV*d:\SymCache*http://symweb;SRV*\\gcrcssfs\Products\Symbols
		- Public Symbol Server (Microsoft)：
			
				srv*c:\mss*http://msdl.microsoft.com/download/symbols
		- Public Symbol Server (Citrix)：	

				srv*c:\css*http://ctxsym.citrix.com/symbols
		- 动态配置Symbol的命令：
		
				.symfix c:\mss
				.sympath+ srv*c:\css*http://ctxsym.citrix.com/symbols

### Common Usage

- Attach Process
- Attach Process on launch
- Open Crash Dump & Analysis
- Open TTTracing & Analysis

### Windbg Reference

- [MSDN](https://msdn.microsoft.com/en-us/library/windows/hardware/ff551063(v=vs.85).aspx)
- [windbg.org](http://www.windbg.org/)
- [QuickStart](https://msdn.microsoft.com/en-us/library/windows/hardware/dn745911(v=vs.85).aspx)
- [windbg.info](http://www.windbg.info/)

## 基本命令

### Command Reference
- Windbg.ino: [Common Commands](http://www.windbg.info/doc/1-common-cmds.html), also you could download: [PDF](http://www.windbg.info/download/doc/pdf/WinDbg_cmds.pdf)
- 练习工具: [CrashMe](http://www.windbg.info/apps/46-crashme.html)

### Command Details

## 常用插件

### sos

### sosext

### psscor2/psscor4

### mex

### iisinfo

## 常见问题的排查思路（三板斧）

### Crash
- 确定异常类型，Crash大致有三种
	- 真正的Crash（SecondChance异常）：程序抛出未捕捉异常，进程崩溃退出
	- First Chance Exception：异常被捕捉到，进程没有退出
		- 部分应用程序会有自己的Application Log，可以看到Try/Catch逻辑中打出的Log，从而确认有FirstChance异常
		- 另一部分应用程序会借用Windows EventLog，把异常信息输出到Application EventLog中
	- 进程结束，但不是Crash，而是应用程序的代码逻辑自己结束了进程
- 收集Crash Dump
	- 对于SecondChance异常，直接收集Crash Dump
		- DebugDiag
		- Procdump
		- WER
	- 对于FirstChance异常，需要先确定异常类型（如果没有就收集所有的异常类型，收集10个）
		- DebugDiag
		- Procdump
	- 对于进程自行结束的，可以针对Terminate事件收集Dump
		- DebugDiag
		- Procdump
- 分析异常原因
	- .NET异常
		- 在StackObject或者GCHeap中找到异常对象
		- 打印Callstack，结合DSO和Review Code（SaveAllModule & ILSpy）
	- Native异常 
		- 找到异常抛出点
		- Callstack+传入参数+Symbol文件

### Hang
- 收集Hang Dump
	- 在进程Hang的时候，间隔10秒左右，手动敲命令收集，通常收集3个dump
	- 对于偶发性Hang，Hang时不方便手动收集的情况，可以设置DebugDiag或者Procdump规则，自动收集Dump。
- 分析Hang的原因
	- 对比Dump的Callstack，看Pending在哪些线程
	- 看`!lock`或者`!syncblk`，看是否有死锁现象
- 常见的Hang原因
	- GC
	- 等WebService返回
	- 等DB返回
	- AsyncLock
	- SessionLock
	- 死锁

### High CPU
- 定位什么进程占用了主要的CPU资源
	- 性能计数器（Performance Counter）
	- 任务管理器（TaskManager）也可以，但它只能看当前时刻的情况，不能记录下趋势和时间的Map关系
- 定位什么线程占用了主要的CPU资源
	- 确定了哪一个进程之后，可以在问题发生时，间隔10秒左右，收集3个User Mode Dump
	- 收集Dump后通过`!runaway 3`找到各个线程的CPU占用时间
	- 比对收集时间相邻的Dump，可以找到CPU占用时间较多的线程是哪些
- 看哪些业务逻辑/代码消耗了这些CPU资源
	- 对Dump中（当前）占用CPU最多的线程，Dump Callstack，看问题发生时他们在执行什么代码
	- 将DLL Dump出来，反编译，Review源码
	- Research，看哪些Code Pattern可能造成CPU资源较高
- 常见的Pattern
	- 频繁GC：GC Time超过15%
	- 正则表达式
	- 字符串处理
	- LINQ
	- 无阻塞的无限循环   

### Memory Leak
- 确定是不是Memory Leak
	- 服务进程业务量下降时，Memory是否会随之下降？
	- Tab或者WinForm窗口关闭时，客户端进程的Memory是否会随之下降？
	- 如果Memory只升不降，那么Memory Leak的可能性较大
- 对Memory Leak，收集Dump，分析Leak类型
	- 在Memory上升阶段，收集若干dump，比如1G/1.5G/2G
	- 如果不方便手动收集，可以编写脚本，用Procdump收集，或者DebugDiag
	- 分析Dump，可以看到内存增加的主要部分是什么
		- GC Heap
		- Dynamic Assembly
		- Native Heap
		- Native Unknown 
- 对Native Memory Leak，Hook Track Leak，收集Dump，分析原因
	- DebugDiag & TrackLeak.dll
	- 自动分析
		- DebugDiag Analysis
		- 或者`!analysis -v hang`

## 案例介绍

### IIS Hang

### IE Crash