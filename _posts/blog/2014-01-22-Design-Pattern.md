---
layout:         post
title:          Design Pattern摘录
category:       blog
description:    小结设计模式的What/Why/How，以C#和Python分别举例
---

## Overview
- 创建型模式
	- 创建对象
	- 为类如何实例化对象提供指南
- 结构型模式
	- 处理类和对象的组合
	- 对类如何设计以形成更大的结构提供指南
- 行为型模式
	- 描述类或对象的交互以及职责的交互
	- 对类之间交互以及分配责任提供指南

## 原则
- 总原则：开放-封闭原则
	- 对扩展开放，对修改封闭，可以用新的类来解决问题
- 单一职责原则
	- 设计目的单一的类。也就是降低程序的耦和程度
- 里氏替换原则
	- 用子类去替代父类
- 依赖倒置原则
	- 依赖于抽象，而不依赖于具体的实现
	- 针对接口编程，不针对实现编程
- 接口隔离原则
	- 使用多个接口总比使用单个接口要好
- 组合重用原则
	- 尽量使用组合，而不是使用继承来达到重用的目的，因为继承是一种紧耦合
- 最少知道原则
	- 一个对象应当对其他对象有尽可能少的了解，即信息隐蔽

## 经典-设计模式

### 创建型
- 工厂方法模式（Factory Method）
	- 定义一个创建对象的接口，由子类决定需要实例化哪一个类
	- 工厂方法使得子类的实例化过程推迟
- 抽象工厂模式（Abstract Factory）
	- 提供一个接口，可以创建一系列对象，而不用制定它们具体的类
- 构建器模式（Builder）
	- 将一个复杂类的表示与其构造相分离，使得相同的构建过程能得到不同的表示
- 原型模式（Prototype）
	- 用原型实例指定创建对象的类型，并通过copy这个原型来创建新的对象
- 单例模式（Singleton）
	- 保证一个类只有一个实例，并提供一个访问它的全局访问点

### 结构型
- 适配器模式（Adapter）
	- 将一个类的接口转换成用户希望得到的另一种接口。
- 桥接模式（Bridge）
	- 将类的抽象部分和实现部分分离开来，使它们可以独立地变化。
- 组合模式（Composite）
	- 将对象组合成树形结构以表示“整体-部分”的层次结构，对单个对象和组合对象的使用具有一致性。
- 装饰模式（Decorator）
	- 动态给一个对象添加一些额外的职责。
- 外观模式（Facade）
	- 定义一个高层接口，为子系统中的一组接口提供一个一致的外观，即对外统一接口
- 享元模式（Flyweight）
	- 提供支持大量细粒度对象共享的有效方法。
- 代理模式（Proxy）
	- 为其他对象提供一种代理以控制这个对象的访问。

### 行为型
- 职责链模式（Chain of Responsibility）
	- 通过给多个对象处理请求的机会，减少请求发送者与接收者之间的耦合。
	- 将接收对象链接起来，在链中传递请求，直到有一个对象处理这个请求。
- 命令模式（Command）
	- 将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化
	- 将请求排队或者记录请求日志，支持可撤销操作。
- 解释器模式（Interpreter）
	- 给定一种语言，定义它的文法表示，并定义一个解释器
	- 该解释器用来根据文法表示来解释语言中的句子。
- 迭代器模式（Iterator）
	- 提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。
- 中介者模式（Mediator）
	- 用一个中介对象来封装一系列的交互。它使各对象不需要显式地相互调用，从而达到低耦合
	- 还可以独立地改变对象之间的交互，也就是将网状结构该为星形结构
- 备忘录模式（Memento）
	- 保存一个对象的某个状态，以便在适当的时候恢复对象
- 观察者模式（Observer）
	- 定义对象之间的一种一对多的依赖关系
	- 当一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动更新，用于：联动/发布和订阅
- 状态模式（State）
	- 允许一个对象在其内部状态改变时改变他的行为，状态变成类，例如：会员卡的状态（铜－银－金）
- 策略模式（Strategy）
	- 定义一系列算法，把它们一个个封装起来，并且使它们之间可相互替换，从而让算法可以独立于使用它的用户而变化。
- 模版方法模式（Template Method）
	- 定义一个操作中的算法骨架，而将一些步骤延迟到子类中。
- 访问者模式（Visitor）
	- 一种分离对象数据结构与行为的方法。
	- 通过这种分离，可达到一个被访问者动态添加新的操作而无需做其他修改的效果。
	- 适用于数据结构相对稳定，算法易变化的系统。

## Python-设计模式
- 工厂、建造者、原型
- 适配器、装饰器、外观、享元、MVC、代理
- 责任链、命令、解释器、观察者、状态、策略、模板
