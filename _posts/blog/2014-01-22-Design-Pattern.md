---
layout:         post
title:          Design Pattern摘录
category:       blog
description:    小结设计模式的What/Why/How，以C#和Python分别举例
---

## Overview
- 面向对象（OO，Object-oriented）之于23种设计模式，犹如诡道兵法之于36计。
	- 兵法千变万化，定势36计；设计模式也是如此，23种设计模式只是对包罗万象的面向对象设计案例的整理归类，是**抽象的OO思想的具体表现**。
	- 离开了具体的计谋来谈兵法，兵法就虚无缥缈，难以表达和学习；离开了设计模式来学习和讨论面向对象也是如此，设计模式使得面向对象的程序设计思想**便于描述和理解**。讨论时程序架构时说“工厂模式”，有如讨论兵法时说“美人计”或者“围魏救赵”，对方一听就明白了。
	- 在简单的场景用了过于复杂，或者不适合的计谋，会适得其反；设计模式也是如此。但用错了设计模式不至于“军败身死”，刚开始学习的同学**不妨多读多想、多试多用**，了解每种设计模式的优缺点，应用场景，然后就能恰到好处地使用它们了。达到这种中庸的境界，需要在github上不断地修炼。
- 设计模式的总原则：**开放-封闭原则**，OCP(Open-Closed Principle)，对功能扩展开放，对代码修改封闭
	- 借鉴敏捷开发的思想，不对功能扩展作超出当前需求的假设，代码实现刚好够用的功能即可。
	- 对于新增功能，如果需要通过修改代码来实现功能扩展，那就一定不要再远基础上修改代码，而是必须**重构**（Refactoring），重构时要确保做到对当前扩展不修改代码，只新增代码。
- 历史
	- 1977/79年，建筑师-克里斯托佛·亚历山大(Christopher Alexander)编制了一本汇集建筑领域设计模式的书。
	- 1987年，肯特·贝克和沃德·坎宁安利用了亚历山大的设计模式思想，把它们应用在了Smalltalk中的图形用户接口（GUI）的生成代码中。
	- 1988年，埃里希·伽玛（Erich Gamma）在他的苏黎世大学**博士毕业论文**中开始尝试把这种思想改写为适用于软件开发。与此同时James Coplien在1989年至1991年也在利用相同的思想致力于C++的开发，而后于1991年发表了他的著作《Advanced C++ Programming Styles and Idioms》。
	- 还是在1988年，Erich Gamma获得博士学位后去往了美国。在那里，他结识了Richard Helm, Ralph Johnson, John Vlissides。他们合作出版了：《设计模式：可复用面向对象软件的基础》（Design Patterns - Elements of Reusable Object-Oriented Software. 1995年出版，出版社：Addison Wesly Longman.Inc）。在这之后，设计模式的思想很快传播开来并深刻影响了之后的软件开发领域。这四位作者也在软件开发领域里以**GoF**（“四人帮”，即**Gang of Four : Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides**）而闻名于世。有时，GoF也会用于代指《设计模式》这本书。
	- ![Design-Pattern-GOF](https://raw.githubusercontent.com/wu-wenxiang/Media-WebLink/master/qiniu/d3982739435445939afcf1c492cddf08-Design-Pattern-GOF.png)

## 衍化的六大原则
- **单一职责原则（Single responsibility principle，SRP）**
	- 设计目的单一的类，一个类只负责一个职责，把这个职责最到最好（紧内聚）
	- 如果一个类承担的职责过多，等于将这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其它职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到的破坏
	- 将多个职责分开，各自对应到一个单独的类，这样一个职责的变化只涉及到一个类的变化，与其它类无关
	- 举例来说，MVC，数据模型/界面/业务逻辑，各自独立。
- **里氏替换原则（Liskov Substitution principle，LSP）**
	- 子类可以完全替代父类
- 依赖倒置原则
	- 依赖于抽象，而不依赖于具体的实现
	- 针对接口编程，不针对实现编程
	- 所谓依赖倒置，是指本来写代码是自下而上（先写好底层的类库，然后上层调用依赖底层类库的实现），现在自上而下（上层代码约定好借口，底层类库提供接口）
- 接口隔离原则
	- 使用多个接口总比使用单个接口要好
- 组合重用原则
	- 尽量使用组合，而不是使用继承来达到重用的目的，因为继承是一种紧耦合
- 最少知道原则
	- 一个对象应当对其他对象有尽可能少的了解，即信息隐蔽

## 设计模式的分类
- 创建型模式
	- 创建对象
	- 为类如何实例化对象提供指南
- 结构型模式
	- 处理类和对象的组合
	- 对类如何设计以形成更大的结构提供指南
- 行为型模式
	- 描述类或对象的交互以及职责的交互
	- 对类之间交互以及分配责任提供指南

## 经典-设计模式

### 创建型
- 工厂方法模式（Factory Method）
	- 定义一个创建对象的接口，由子类决定需要实例化哪一个类
	- 工厂方法使得子类的实例化过程推迟
- 抽象工厂模式（Abstract Factory）
	- 提供一个接口，可以创建一系列对象，而不用制定它们具体的类
- 构建器模式（Builder）
	- 将一个复杂类的表示与其构造相分离，使得相同的构建过程能得到不同的表示
- 原型模式（Prototype）
	- 用原型实例指定创建对象的类型，并通过copy这个原型来创建新的对象
- 单例模式（Singleton）
	- 保证一个类只有一个实例，并提供一个访问它的全局访问点

### 结构型
- 适配器模式（Adapter）
	- 将一个类的接口转换成用户希望得到的另一种接口。
- 桥接模式（Bridge）
	- 将类的抽象部分和实现部分分离开来，使它们可以独立地变化。
- 组合模式（Composite）
	- 将对象组合成树形结构以表示“整体-部分”的层次结构，对单个对象和组合对象的使用具有一致性。
- 装饰模式（Decorator）
	- 动态给一个对象添加一些额外的职责。
- 外观模式（Facade）
	- 定义一个高层接口，为子系统中的一组接口提供一个一致的外观，即对外统一接口
- 享元模式（Flyweight）
	- 提供支持大量细粒度对象共享的有效方法。
- 代理模式（Proxy）
	- 为其他对象提供一种代理以控制这个对象的访问。

### 行为型
- 职责链模式（Chain of Responsibility）
	- 通过给多个对象处理请求的机会，减少请求发送者与接收者之间的耦合。
	- 将接收对象链接起来，在链中传递请求，直到有一个对象处理这个请求。
- 命令模式（Command）
	- 将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化
	- 将请求排队或者记录请求日志，支持可撤销操作。
- 解释器模式（Interpreter）
	- 给定一种语言，定义它的文法表示，并定义一个解释器
	- 该解释器用来根据文法表示来解释语言中的句子。
- 迭代器模式（Iterator）
	- 提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。
- 中介者模式（Mediator）
	- 用一个中介对象来封装一系列的交互。它使各对象不需要显式地相互调用，从而达到低耦合
	- 还可以独立地改变对象之间的交互，也就是将网状结构该为星形结构
- 备忘录模式（Memento）
	- 保存一个对象的某个状态，以便在适当的时候恢复对象
- 观察者模式（Observer）
	- 定义对象之间的一种一对多的依赖关系
	- 当一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动更新，用于：联动/发布和订阅
- 状态模式（State）
	- 允许一个对象在其内部状态改变时改变他的行为，状态变成类，例如：会员卡的状态（铜－银－金）
- 策略模式（Strategy）
	- 定义一系列算法，把它们一个个封装起来，并且使它们之间可相互替换，从而让算法可以独立于使用它的用户而变化。
- 模版方法模式（Template Method）
	- 定义一个操作中的算法骨架，而将一些步骤延迟到子类中。
- 访问者模式（Visitor）
	- 一种分离对象数据结构与行为的方法。
	- 通过这种分离，可达到一个被访问者动态添加新的操作而无需做其他修改的效果。
	- 适用于数据结构相对稳定，算法易变化的系统。

## Python-设计模式
- 工厂、建造者、原型
- 适配器、装饰器、外观、享元、MVC、代理
- 责任链、命令、解释器、观察者、状态、策略、模板
